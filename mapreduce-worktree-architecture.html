<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>MapReduce Worktree Architecture - Prodigy Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="AI-powered workflow orchestration for development teams">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Prodigy Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/iepathos/prodigy" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/iepathos/prodigy/edit/main/book/src/mapreduce-worktree-architecture.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="mapreduce-worktree-architecture"><a class="header" href="#mapreduce-worktree-architecture">MapReduce Worktree Architecture</a></h1>
<p>MapReduce workflows in Prodigy use an isolated git worktree architecture that ensures the main repository remains untouched during workflow execution. This chapter explains the worktree hierarchy, branch naming conventions, merge flows, and debugging strategies.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>When you run a MapReduce workflow, Prodigy creates a hierarchical worktree structure:</p>
<pre><code>Main Repository (untouched during execution)
    ↓
Parent Worktree (session-mapreduce-{id})
    ├── Setup Phase → Executes here
    ├── Reduce Phase → Executes here
    └── Map Phase → Each agent in child worktree
        ├── Child Worktree (mapreduce-agent-{id})
        ├── Child Worktree (mapreduce-agent-{id})
        └── Child Worktree (mapreduce-agent-{id})
</code></pre>
<p>This architecture provides complete isolation, allowing parallel agents to work independently while preserving a clean main repository.</p>
<h2 id="worktree-hierarchy"><a class="header" href="#worktree-hierarchy">Worktree Hierarchy</a></h2>
<h3 id="parent-worktree"><a class="header" href="#parent-worktree">Parent Worktree</a></h3>
<p>Created at the start of MapReduce workflow execution:</p>
<p><strong>Location</strong>: <code>~/.prodigy/worktrees/{project}/session-mapreduce-{timestamp}</code></p>
<p><strong>Purpose</strong>:</p>
<ul>
<li>Isolates all workflow execution from main repository</li>
<li>Hosts setup phase execution</li>
<li>Hosts reduce phase execution</li>
<li>Serves as merge target for agent results</li>
</ul>
<p><strong>Branch</strong>: Follows <code>prodigy-{session-id}</code> pattern. The session ID includes a timestamp (e.g., <code>session-mapreduce-20250112_143052</code>), so the full branch name becomes <code>prodigy-session-mapreduce-20250112_143052</code> (source: src/worktree/builder.rs:176-178)</p>
<p><strong>Worktree Allocation Strategies</strong>:</p>
<p>All worktrees in Prodigy have names, paths, and git branches - the distinction is in how they’re allocated:</p>
<ul>
<li>
<p><strong>Directly-Created Worktrees</strong>: MapReduce coordinators create session worktrees with explicit, predictable names (e.g., <code>session-mapreduce-20250112_143052</code>). These have deterministic paths and are easy to locate.</p>
</li>
<li>
<p><strong>Pool-Allocated Worktrees</strong>: When agents request worktrees via <code>WorktreeRequest::Anonymous</code> (source: src/cook/execution/mapreduce/resources/worktree.rs:42), they receive pre-allocated worktrees from a shared pool. These worktrees have pool-assigned names rather than request-specific names. The pool allocation strategy enables efficient resource reuse across multiple agents.</p>
</li>
</ul>
<p><strong>Important</strong>: Both allocation strategies produce worktrees with full identity (name, path, branch). The difference is in naming predictability and resource management approach.</p>
<h3 id="child-worktrees"><a class="header" href="#child-worktrees">Child Worktrees</a></h3>
<p>Created for each map agent:</p>
<p><strong>Location</strong>: <code>~/.prodigy/worktrees/{project}/mapreduce-agent-{agent_id}</code></p>
<p><strong>Purpose</strong>:</p>
<ul>
<li>Complete isolation per agent</li>
<li>Independent failure handling</li>
<li>Parallel execution safety</li>
</ul>
<p><strong>Branch</strong>: Follows <code>prodigy-{worktree-name}</code> pattern (branched from parent worktree)</p>
<p><strong>Resource Management</strong>: Agent worktrees can be acquired through two strategies:</p>
<ol>
<li>
<p><strong>Worktree Pool</strong> (preferred): Agents first attempt to acquire pre-allocated worktrees from a <code>WorktreePool</code>. This reduces creation overhead and enables efficient resource reuse.</p>
</li>
<li>
<p><strong>Direct Creation</strong> (fallback): If the pool is exhausted or unavailable, agents fall back to creating dedicated worktrees via <code>WorktreeManager</code>.</p>
</li>
</ol>
<p>The <code>acquire_session</code> method implements this pool-first strategy, ensuring optimal resource utilization while maintaining isolation guarantees.</p>
<p><strong>Note</strong>: The <code>agent_id</code> in the location path encodes the work item information. Agent worktrees are created dynamically as map agents execute.</p>
<h2 id="branch-naming-conventions"><a class="header" href="#branch-naming-conventions">Branch Naming Conventions</a></h2>
<p>Prodigy uses consistent branch naming to track worktree relationships:</p>
<h3 id="parent-worktree-branch"><a class="header" href="#parent-worktree-branch">Parent Worktree Branch</a></h3>
<p>Format: <code>prodigy-{session-id}</code></p>
<p>The branch name follows the universal worktree pattern where all worktrees use <code>prodigy-{name}</code>. For MapReduce workflows, the session ID itself includes the timestamp, so the full branch name looks like:</p>
<p>Example: <code>prodigy-session-mapreduce-20250112_143052</code></p>
<p>This is <code>prodigy-</code> + the session ID <code>session-mapreduce-20250112_143052</code></p>
<h3 id="agent-worktree-branch"><a class="header" href="#agent-worktree-branch">Agent Worktree Branch</a></h3>
<p>Format: <code>prodigy-{worktree-name}</code></p>
<p>All worktrees in Prodigy follow the universal <code>prodigy-{name}</code> branch naming pattern (source: src/worktree/builder.rs:178). The worktree name itself varies based on the allocation strategy:</p>
<p><strong>Pool-Allocated Worktrees</strong>: When agents acquire worktrees from the pre-allocated pool, the worktree name is generated by the pool and may not follow a predictable pattern. These are still tracked by the consistent <code>prodigy-{name}</code> branch format.</p>
<p><strong>Directly-Created Worktrees</strong>: When agents create dedicated worktrees (fallback when pool is exhausted), the name typically encodes job and agent information.</p>
<p>Example: <code>prodigy-mapreduce-agent-mapreduce-20251109_193734_agent_22</code></p>
<p>This is <code>prodigy-</code> + the worktree name <code>mapreduce-agent-mapreduce-20251109_193734_agent_22</code></p>
<p><strong>Directly-Created Worktree Name Components</strong>:</p>
<ul>
<li><code>mapreduce-agent-</code>: Indicates this is a MapReduce agent worktree</li>
<li><code>{job_id}</code>: The MapReduce job identifier (includes timestamp)</li>
<li><code>_agent_{n}</code>: Sequential agent number within the job</li>
</ul>
<p><strong>Note</strong>: The branch naming is always consistent (<code>prodigy-{name}</code>), but worktree naming varies based on allocation strategy.</p>
<h2 id="merge-flow"><a class="header" href="#merge-flow">Merge Flow</a></h2>
<p>MapReduce workflows involve multiple merge operations to aggregate results:</p>
<h3 id="1-agent-merge-child--parent"><a class="header" href="#1-agent-merge-child--parent">1. Agent Merge (Child → Parent)</a></h3>
<p>When an agent completes successfully:</p>
<pre><code>Child Worktree (agent branch)
    ↓ merge
Parent Worktree (session branch)
</code></pre>
<p><strong>Process</strong>:</p>
<ol>
<li>Agent completes all commands successfully</li>
<li>Agent commits changes to its branch</li>
<li>Merge coordinator adds agent to merge queue</li>
<li>Sequential merge into parent worktree branch</li>
<li>Child worktree cleanup</li>
</ol>
<h3 id="2-mapreduce-to-parent-merge"><a class="header" href="#2-mapreduce-to-parent-merge">2. MapReduce to Parent Merge</a></h3>
<p>After all map agents complete and reduce phase finishes:</p>
<pre><code>Parent Worktree (session branch)
    ↓ merge
Main Repository (original branch)
</code></pre>
<p><strong>Process</strong>:</p>
<ol>
<li>All agents merged into parent worktree</li>
<li>Reduce phase executes in parent worktree</li>
<li>User confirms merge to main repository</li>
<li>Sequential merge with conflict detection</li>
<li>Parent worktree cleanup</li>
</ol>
<h3 id="merge-strategies"><a class="header" href="#merge-strategies">Merge Strategies</a></h3>
<p><strong>Fast-Forward When Possible</strong>: If no divergence, use fast-forward merge</p>
<p><strong>Three-Way Merge</strong>: When branches have diverged, perform three-way merge</p>
<p><strong>Conflict Handling</strong>: Stop and report conflicts for manual resolution</p>
<h2 id="agent-merge-details"><a class="header" href="#agent-merge-details">Agent Merge Details</a></h2>
<h3 id="merge-queue"><a class="header" href="#merge-queue">Merge Queue</a></h3>
<p>Agents are added to a merge queue as they complete:</p>
<p><strong>Queue Architecture</strong>: Merge queue is managed in-memory by a background worker task using a tokio unbounded mpsc channel (<code>mpsc::unbounded_channel::&lt;MergeRequest&gt;()</code>). Merge requests are processed sequentially via this channel, eliminating MERGE_HEAD race conditions. Queue state is not persisted - merge operations are atomic (source: src/cook/execution/mapreduce/merge_queue.rs:70).</p>
<p><strong>Resume and Recovery</strong>: The merge queue state is reconstructed on resume from checkpoint data (source: src/cook/execution/mapreduce/merge_queue.rs:153). When a MapReduce workflow is interrupted and resumed, the queue is rebuilt based on:</p>
<ul>
<li>Completed agents: Already merged, skip re-merging</li>
<li>Failed agents: Tracked in DLQ, can be retried separately</li>
<li>In-progress agents: Moved back to pending status, will be re-executed</li>
<li>Pending agents: Continue processing from where left off</li>
</ul>
<p>Any in-progress merges at the time of interruption are retried from the agent worktree state. This ensures no agent results are lost during resume.</p>
<p><strong>Queue Processing</strong>: Queue processes <code>MergeRequest</code> objects containing:</p>
<ul>
<li><code>agent_id</code>: Unique agent identifier</li>
<li><code>branch_name</code>: Agent’s git branch to merge</li>
<li><code>item_id</code>: Work item identifier for correlation</li>
<li><code>env</code>: Execution environment context (variables, secrets)</li>
</ul>
<p>Merge requests are processed FIFO with automatic conflict detection.</p>
<h3 id="sequential-merge-processing"><a class="header" href="#sequential-merge-processing">Sequential Merge Processing</a></h3>
<p>Merges are processed sequentially to prevent conflicts:</p>
<ol>
<li>Lock merge queue</li>
<li>Take next agent from pending queue</li>
<li>Perform merge into parent worktree</li>
<li>Update queue (move to merged or failed)</li>
<li>Release lock</li>
</ol>
<h3 id="automatic-conflict-resolution"><a class="header" href="#automatic-conflict-resolution">Automatic Conflict Resolution</a></h3>
<p>If a standard git merge fails with conflicts, the merge queue automatically invokes Claude using the <code>/prodigy-merge-worktree</code> command to resolve conflicts intelligently:</p>
<p><strong>Conflict Resolution Flow</strong>:</p>
<ol>
<li>Standard git merge attempted</li>
<li>If conflicts detected, invoke Claude with <code>/prodigy-merge-worktree {branch_name}</code></li>
<li>Claude is executed with <code>PRODIGY_AUTOMATION=true</code> environment variable (source: src/cook/execution/mapreduce/merge_queue.rs:98-99)</li>
<li>Claude analyzes conflicts and attempts resolution</li>
<li>If Claude succeeds, merge completes automatically</li>
<li>If Claude fails, agent is marked as failed and added to DLQ</li>
</ol>
<p><strong>PRODIGY_AUTOMATION Environment Variable</strong>: When set to <code>true</code>, this signals to Claude Code that it’s operating in automated workflow mode and should use appropriate merge strategies without requiring user interaction. Claude will attempt to resolve conflicts autonomously using standard git merge strategies and code analysis.</p>
<p><strong>Benefits</strong>:</p>
<ul>
<li>Reduces manual merge conflict resolution overhead</li>
<li>Handles common conflict patterns automatically</li>
<li>Preserves full context for debugging via Claude logs</li>
<li>Falls back gracefully to DLQ for complex conflicts</li>
<li>Automated execution mode ensures non-interactive conflict resolution</li>
</ul>
<p>This automatic conflict resolution is especially useful when multiple agents modify overlapping code areas.</p>
<h2 id="parent-to-master-merge"><a class="header" href="#parent-to-master-merge">Parent to Master Merge</a></h2>
<h3 id="merge-confirmation"><a class="header" href="#merge-confirmation">Merge Confirmation</a></h3>
<p>After reduce phase completes, Prodigy prompts for merge confirmation:</p>
<pre><code>✓ MapReduce workflow completed successfully

Merge session-mapreduce-20250112_143052 to master? [y/N]
</code></pre>
<h3 id="custom-merge-workflows"><a class="header" href="#custom-merge-workflows">Custom Merge Workflows</a></h3>
<p>Configure custom merge validation:</p>
<pre><code class="language-yaml">merge:
  - shell: "git fetch origin"
  - shell: "cargo test"
  - shell: "cargo clippy"
  - claude: "/prodigy-merge-worktree ${merge.source_branch} ${merge.target_branch}"
</code></pre>
<p><strong>Important</strong>: Always pass both <code>${merge.source_branch}</code> and <code>${merge.target_branch}</code> to the <code>/prodigy-merge-worktree</code> command (source: .claude/commands/prodigy-merge-worktree.md). This ensures the merge targets the branch you were on when you started the workflow, not a hardcoded main/master branch.</p>
<h3 id="merge-variables"><a class="header" href="#merge-variables">Merge Variables</a></h3>
<p>Available during merge workflows:</p>
<ul>
<li><code>${merge.worktree}</code> - Worktree name</li>
<li><code>${merge.source_branch}</code> - Session branch name</li>
<li><code>${merge.target_branch}</code> - Main repository branch (usually master/main)</li>
<li><code>${merge.session_id}</code> - Session ID for correlation</li>
</ul>
<h2 id="debugging-mapreduce-worktrees"><a class="header" href="#debugging-mapreduce-worktrees">Debugging MapReduce Worktrees</a></h2>
<h3 id="inspecting-worktree-state"><a class="header" href="#inspecting-worktree-state">Inspecting Worktree State</a></h3>
<pre><code class="language-bash"># List all worktrees
git worktree list

# View worktree details
cd ~/.prodigy/worktrees/{project}/session-mapreduce-*
git status
git log

# View agent worktree
cd ~/.prodigy/worktrees/{project}/agent-*
git log --oneline
</code></pre>
<h3 id="finding-agent-worktree-paths"><a class="header" href="#finding-agent-worktree-paths">Finding Agent Worktree Paths</a></h3>
<p>Agent worktrees may be <strong>directly-created</strong> (with predictable names) or <strong>pool-allocated</strong> (with pool-assigned names). To correlate agent IDs to worktree paths:</p>
<p><strong>Directly-Created Worktrees</strong> (deterministic paths):</p>
<pre><code class="language-bash"># Pattern: ~/.prodigy/worktrees/{project}/mapreduce-agent-{job_id}_agent_{n}
cd ~/.prodigy/worktrees/{project}/mapreduce-agent-*
</code></pre>
<p><strong>Pool-Allocated Worktrees</strong> (pool-assigned paths):</p>
<pre><code class="language-bash"># List all worktrees and correlate by branch name
git worktree list

# Look for branches matching agent pattern
git branch -a | grep prodigy-mapreduce-agent
</code></pre>
<p><strong>Note</strong>: Both allocation strategies produce fully-identified worktrees with names, paths, and branches. Pool allocation assigns names from the pool’s naming scheme, while direct creation uses request-specific naming patterns. Use <code>WorktreeInfo</code> tracking (described below) to correlate agent IDs to actual worktree locations.</p>
<p><strong>WorktreeInfo Tracking</strong>: Prodigy captures worktree metadata in <code>WorktreeInfo</code> structs containing:</p>
<ul>
<li><code>name</code>: Worktree identifier</li>
<li><code>path</code>: Full filesystem path</li>
<li><code>branch</code>: Git branch name</li>
</ul>
<p>This information is logged in MapReduce events and can be inspected via <code>prodigy events {job_id}</code> to correlate agent IDs to worktree paths.</p>
<h3 id="common-debugging-scenarios"><a class="header" href="#common-debugging-scenarios">Common Debugging Scenarios</a></h3>
<p><strong>Agent Failed to Merge:</strong></p>
<ol>
<li>Check DLQ for failure details: <code>prodigy dlq show {job_id}</code></li>
<li>Inspect failed agent worktree: <code>cd ~/.prodigy/worktrees/{project}/mapreduce-agent-*</code></li>
<li>Review agent changes: <code>git diff master</code></li>
<li>Check for conflicts: <code>git status</code></li>
<li>Review Claude merge logs if conflict resolution was attempted</li>
</ol>
<p><strong>Parent Worktree Not Merging:</strong></p>
<ol>
<li>Check parent worktree: <code>cd ~/.prodigy/worktrees/{project}/session-mapreduce-*</code></li>
<li>Verify all agents merged: <code>git log --oneline</code></li>
<li>Check for uncommitted changes: <code>git status</code></li>
<li>Review merge history: <code>git log --graph --oneline --all</code></li>
</ol>
<h3 id="merge-conflict-resolution"><a class="header" href="#merge-conflict-resolution">Merge Conflict Resolution</a></h3>
<p>If merge conflicts occur:</p>
<pre><code class="language-bash"># Navigate to parent worktree
cd ~/.prodigy/worktrees/{project}/session-mapreduce-*

# View conflicts
git status

# Resolve manually
vim &lt;conflicted-file&gt;

# Complete merge
git add &lt;conflicted-file&gt;
git commit
</code></pre>
<h2 id="verification-commands"><a class="header" href="#verification-commands">Verification Commands</a></h2>
<h3 id="verify-main-repository-is-clean"><a class="header" href="#verify-main-repository-is-clean">Verify Main Repository is Clean</a></h3>
<pre><code class="language-bash"># Main repository should have no changes from MapReduce execution
git status
# Expected: nothing to commit, working tree clean
</code></pre>
<h3 id="verify-worktree-isolation"><a class="header" href="#verify-worktree-isolation">Verify Worktree Isolation</a></h3>
<pre><code class="language-bash"># Check that parent worktree has changes
cd ~/.prodigy/worktrees/{project}/session-mapreduce-*
git status
git log --oneline

# Main repository should still be clean
cd /path/to/main/repo
git status
</code></pre>
<h3 id="verify-agent-merges"><a class="header" href="#verify-agent-merges">Verify Agent Merges</a></h3>
<pre><code class="language-bash"># Check for merge events
prodigy events {job_id}

# Verify merged agents in parent worktree
cd ~/.prodigy/worktrees/{project}/session-mapreduce-*
git log --oneline | grep "Merge"
</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="worktree-management"><a class="header" href="#worktree-management">Worktree Management</a></h3>
<ul>
<li><strong>Cleanup</strong>: Remove old worktrees after successful merge: <code>prodigy worktree clean</code></li>
<li><strong>Monitoring</strong>: Check worktree disk usage periodically</li>
<li><strong>Inspection</strong>: Review worktrees before deleting to verify results</li>
</ul>
<h3 id="merge-workflows"><a class="header" href="#merge-workflows">Merge Workflows</a></h3>
<ul>
<li><strong>Test Before Merge</strong>: Run tests in merge workflow to catch issues</li>
<li><strong>Sync Upstream</strong>: Fetch and merge origin/main before merging to main</li>
<li><strong>Conflict Prevention</strong>: Keep MapReduce jobs focused to minimize conflicts</li>
</ul>
<h3 id="debugging"><a class="header" href="#debugging">Debugging</a></h3>
<ul>
<li><strong>Preserve Worktrees</strong>: Don’t delete worktrees until debugging is complete</li>
<li><strong>Event Logs</strong>: Review event logs for merge failures: <code>prodigy events {job_id}</code></li>
<li><strong>DLQ Review</strong>: Check failed items that might indicate merge issues</li>
</ul>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="worktree-creation-fails"><a class="header" href="#worktree-creation-fails">Worktree Creation Fails</a></h3>
<p><strong>Issue</strong>: Cannot create parent or child worktree
<strong>Solution</strong>: Check disk space, verify git repository is valid, ensure no existing worktree with same name</p>
<h3 id="agent-merge-fails"><a class="header" href="#agent-merge-fails">Agent Merge Fails</a></h3>
<p><strong>Issue</strong>: Agent results fail to merge into parent
<strong>Solution</strong>: Check merge queue, inspect agent worktree for conflicts, review agent changes</p>
<h3 id="parent-merge-conflicts"><a class="header" href="#parent-merge-conflicts">Parent Merge Conflicts</a></h3>
<p><strong>Issue</strong>: Merging parent worktree to main causes conflicts
<strong>Solution</strong>: Resolve conflicts manually, consider rebasing parent worktree on latest main</p>
<h3 id="orphaned-worktrees"><a class="header" href="#orphaned-worktrees">Orphaned Worktrees</a></h3>
<p><strong>Issue</strong>: Worktrees remain after workflow completion
<strong>Solution</strong>: Use <code>prodigy worktree clean</code> to remove old worktrees, or manually remove with <code>git worktree remove</code></p>
<h2 id="see-also"><a class="header" href="#see-also">See Also</a></h2>
<ul>
<li><a href="mapreduce/index.html">MapReduce Workflows</a> - MapReduce workflow basics</li>
<li><a href="error-handling.html">Error Handling</a> - Handling merge failures</li>
<li><a href="troubleshooting/index.html">Troubleshooting</a> - General troubleshooting guide</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="error-handling.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="automated-documentation/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="error-handling.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="automated-documentation/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
