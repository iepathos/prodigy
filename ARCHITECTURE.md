# Architecture - MMM Git-Native Improvement Flow

## Overview

MMM uses a git-native architecture where each improvement step creates git commits for complete auditability. The system wraps Claude CLI commands in a simple, automated loop.

## Core Architecture

```
mmm improve
    ↓
┌─── Project Analysis ───┐
│ • Language detection    │
│ • Framework detection   │
│ • Health score calc     │
└─────────────────────────┘
    ↓
┌────── IMPROVEMENT LOOP (Max 10 iterations) ──────┐
│                                                   │
│  ┌─ Code Review Step ─┐                          │
│  │ claude /mmm-code-review                       │
│  │ → Analyzes current code                       │
│  │ → Creates specs/temp/iteration-*-improvements.md │
│  │ → Commits: "review: generate improvement spec..." │
│  └─────────────────────┘                          │
│           ↓                                        │
│  ┌─ Spec Extraction ─┐                            │
│  │ git log -1 --pretty=format:"%s"                │
│  │ → Parse commit message                         │
│  │ → Extract spec ID (iteration-timestamp)       │
│  └─────────────────────┘                          │
│           ↓                                        │
│  ┌─ Implementation Step ─┐                        │
│  │ claude /mmm-implement-spec {spec-id}           │
│  │ → Read temporary spec file                     │
│  │ → Apply code fixes                             │
│  │ → Commits: "fix: apply improvements from spec..." │
│  └─────────────────────┘                          │
│           ↓                                        │
│  ┌─ Linting Step ─┐                               │
│  │ claude /mmm-lint                               │
│  │ → cargo fmt                                    │
│  │ → cargo clippy --fix                          │
│  │ → cargo test                                   │
│  │ → Commits: "style: apply automated formatting..." │
│  └─────────────────────┘                          │
│           ↓                                        │
│  ┌─ Re-analysis ─┐                                │
│  │ • Calculate new health score                   │
│  │ • Check if target reached                      │
│  │ • Continue or exit loop                        │
│  └─────────────────────┘                          │
│           ↓                                        │
│      Continue until target reached                 │
│      or no issues found                           │
└───────────────────────────────────────────────────┘
```

## Git-Native Communication

### Why Git-Native?
- **Auditable**: Complete history of what was changed and why
- **Debuggable**: Can inspect any step in the process
- **Simple**: No complex JSON parsing between commands
- **Reliable**: Git operations are robust and well-understood
- **Resumable**: Can continue from any point in history

### Communication Flow
```
mmm improve ←→ git commits ←→ Claude CLI commands

Instead of:
mmm improve ←→ JSON ←→ Claude CLI commands (fragile)
```

### Commit Message Format
- **Review**: `review: generate improvement spec for iteration-{timestamp}-improvements`
- **Implementation**: `fix: apply improvements from spec iteration-{timestamp}-improvements`
- **Linting**: `style: apply automated formatting and lint fixes`

## Module Structure

```
src/
├── main.rs                 # CLI entry point with clap
├── improve/                # Core improvement command
│   ├── mod.rs             # Git-native improvement loop
│   ├── command.rs         # CLI argument definitions
│   └── session.rs         # Basic session types
├── analyzer/              # Project analysis
│   ├── mod.rs            # Main analyzer logic
│   ├── language.rs       # Language detection
│   ├── framework.rs      # Framework detection
│   └── health.rs         # Health score calculation
├── simple_state/          # Minimal state management
│   ├── mod.rs            # State manager interface
│   ├── state.rs          # Core state structures
│   ├── cache.rs          # Basic caching
│   └── types.rs          # Data types
└── lib.rs                # Library exports
```

## State Management

### Simple JSON State
```
.mmm/
├── state.json            # Current score, run count, last run time
├── cache/               # Temporary analysis cache
└── context files        # PROJECT.md, ROADMAP.md for Claude context
```

### Temporary Specs
```
specs/temp/
└── iteration-{timestamp}-improvements.md  # Generated by /mmm-code-review
```

### Git History as Audit Trail
```
* style: apply automated formatting and lint fixes
* fix: apply improvements from spec iteration-1708123789-improvements  
* review: generate improvement spec for iteration-1708123789-improvements
* style: apply automated formatting and lint fixes
* fix: apply improvements from spec iteration-1708123456-improvements
* review: generate improvement spec for iteration-1708123456-improvements
```

## Claude CLI Integration

### Three-Step Process
1. **Review** (`/mmm-code-review`): Analyze code and generate improvement specs
2. **Implement** (`/mmm-implement-spec`): Apply fixes from generated specs  
3. **Lint** (`/mmm-lint`): Format, lint, test, and clean up code

### Automation Mode
- Environment variable: `MMM_AUTOMATION=true`
- Minimal output for automated workflows
- Always commit changes without interactive confirmation
- Robust error handling for command failures

## Error Handling

### Command Failure Strategy
- **Review fails**: Stop iteration, report error
- **Implement fails**: Continue (may be partial improvement)  
- **Lint fails**: Continue (fixes may still be valuable)

### Git Operations
- Check clean working directory before starting
- Handle git conflicts gracefully
- Provide clear error messages
- Allow manual recovery

## Benefits of This Architecture

### 1. Simplicity
- No complex JSON parsing between commands
- Simple git operations that are well-understood
- Each command is independent and testable

### 2. Reliability  
- Git operations are robust and atomic
- Commands can be run independently for debugging
- Clear failure points and recovery options

### 3. Transparency
- Complete audit trail of all changes
- Easy to understand what happened in each iteration
- Can manually inspect or replay any step

### 4. Debuggability
- Temporary specs are human-readable files
- Git history shows exact progression
- Can test individual commands in isolation

This architecture creates a true self-sufficient improvement loop that is simple, reliable, and completely auditable through git history.