<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Available Variables - Prodigy Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="AI-powered workflow orchestration for development teams">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "rust";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Prodigy Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/iepathos/prodigy" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/iepathos/prodigy/edit/main/book/src/variables/available-variables.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="available-variables"><a class="header" href="#available-variables">Available Variables</a></h2>
<p>Prodigy provides a comprehensive set of built-in variables that are automatically available based on your workflow context. All variables use the <code>${variable.name}</code> interpolation syntax.</p>
<h3 id="standard-variables"><a class="header" href="#standard-variables">Standard Variables</a></h3>
<p>These variables capture output from the most recently executed command:</p>
<div class="table-wrapper"><table><thead><tr><th>Variable</th><th>Description</th><th>Example</th></tr></thead><tbody>
<tr><td><code>${last.output}</code></td><td>Output from the last command of any type (shell, claude, handler)</td><td><code>echo ${last.output}</code></td></tr>
<tr><td><code>${last.exit_code}</code></td><td>Exit code from the last command</td><td><code>if [ ${last.exit_code} -eq 0 ]</code></td></tr>
<tr><td><code>${shell.output}</code></td><td>Output from the last shell command specifically</td><td><code>echo ${shell.output}</code></td></tr>
<tr><td><code>${claude.output}</code></td><td>Output from the last Claude command specifically</td><td><code>echo ${claude.output}</code></td></tr>
</tbody></table>
</div>
<p><strong>Note:</strong> Use <code>${last.output}</code> when you need output from any command type. Use <code>${shell.output}</code> or <code>${claude.output}</code> when you specifically want output from that command type.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-yaml">- shell: "cargo test --lib"
- shell: "echo 'Test output: ${shell.output}'"

# last.output works with any command type
- claude: "/analyze-code"
- shell: "echo 'Claude analysis: ${last.output}'"
</code></pre>
<h3 id="computed-variables"><a class="header" href="#computed-variables">Computed Variables</a></h3>
<p>Computed variables are dynamically evaluated at runtime, providing access to external data sources and generated values. These variables are prefixed with specific identifiers that trigger their evaluation.</p>
<p><strong>Source:</strong> src/cook/execution/variables.rs:100-305</p>
<div class="table-wrapper"><table><thead><tr><th>Variable Type</th><th>Syntax</th><th>Description</th><th>Cached</th><th>Example</th></tr></thead><tbody>
<tr><td><strong>Environment</strong></td><td><code>${env.VAR_NAME}</code></td><td>Read environment variable</td><td>Yes</td><td><code>${env.HOME}</code>, <code>${env.PATH}</code></td></tr>
<tr><td><strong>File Content</strong></td><td><code>${file:path/to/file}</code></td><td>Read file contents</td><td>Yes</td><td><code>${file:config.txt}</code>, <code>${file:data.json}</code></td></tr>
<tr><td><strong>Command Output</strong></td><td><code>${cmd:shell-command}</code></td><td>Execute command and capture output</td><td>Yes</td><td><code>${cmd:git rev-parse HEAD}</code>, <code>${cmd:date +%Y}</code></td></tr>
<tr><td><strong>JSON Path</strong></td><td><code>${json:path:from:source_var}</code></td><td>Extract from JSON using JSONPath</td><td>No</td><td><code>${json:$.items[0].name:from:data}</code></td></tr>
<tr><td><strong>Date Format</strong></td><td><code>${date:format}</code></td><td>Current date/time with format</td><td>No</td><td><code>${date:%Y-%m-%d}</code>, <code>${date:%H:%M:%S}</code></td></tr>
<tr><td><strong>UUID</strong></td><td><code>${uuid}</code></td><td>Generate random UUID v4</td><td>No</td><td><code>${uuid}</code> (always unique)</td></tr>
</tbody></table>
</div>
<p><strong>Available in:</strong> All phases</p>
<h4 id="environment-variables-env"><a class="header" href="#environment-variables-env">Environment Variables (<code>env.*</code>)</a></h4>
<p>Access environment variables at runtime. Useful for reading system configuration or secrets.</p>
<p><strong>Source:</strong> src/cook/execution/variables.rs:160-187</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-yaml"># Read user's home directory
- shell: "echo 'Home: ${env.HOME}'"

# Use CI environment variables
- shell: "echo 'Running in ${env.CI_PROVIDER:-local}'"

# Access secrets from environment
- shell: "curl -H 'Authorization: Bearer ${env.API_TOKEN}' https://api.example.com"
</code></pre>
<p><strong>Caching:</strong> Environment variable reads are cached for performance (LRU cache, 100 entries).</p>
<h4 id="file-content-file"><a class="header" href="#file-content-file">File Content (<code>file:</code>)</a></h4>
<p>Read file contents directly into variables. Useful for configuration, templates, or data files.</p>
<p><strong>Source:</strong> src/cook/execution/variables.rs:189-216</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-yaml"># Read version from file
- shell: "echo 'Version: ${file:VERSION}'"

# Use file content in command
- shell: "git commit -m '${file:.commit-message.txt}'"

# Read JSON configuration
- shell: "echo '${file:config.json}' | jq '.database.host'"
</code></pre>
<p><strong>Caching:</strong> File reads are cached (file content is expensive to read repeatedly).</p>
<p><strong>Note:</strong> File paths are relative to workflow execution directory.</p>
<h4 id="command-output-cmd"><a class="header" href="#command-output-cmd">Command Output (<code>cmd:</code>)</a></h4>
<p>Execute shell commands and capture their output as variable values. Powerful for dynamic configuration.</p>
<p><strong>Source:</strong> src/cook/execution/variables.rs:218-256</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-yaml"># Get current git commit
- shell: "echo 'Building from ${cmd:git rev-parse --short HEAD}'"

# Use command output in logic
- shell: "if [ '${cmd:uname}' = 'Darwin' ]; then echo 'macOS'; fi"

# Capture timestamp
- shell: "echo 'Build started at ${cmd:date +%Y-%m-%d_%H-%M-%S}'"

# Dynamic configuration
- shell: "cargo build --jobs ${cmd:nproc}"
</code></pre>
<p><strong>Caching:</strong> Command execution results are cached (commands are expensive to execute repeatedly).</p>
<p><strong>Security Warning:</strong> Be cautious with <code>cmd:</code> variables in untrusted workflows - they execute arbitrary shell commands.</p>
<h4 id="json-path-extraction-json"><a class="header" href="#json-path-extraction-json">JSON Path Extraction (<code>json:</code>)</a></h4>
<p>Extract values from JSON data using JSONPath syntax. Useful for processing complex JSON structures.</p>
<p><strong>Source:</strong> src/cook/execution/variables.rs:350-379</p>
<p><strong>Syntax:</strong> <code>${json:path:from:source_variable}</code></p>
<p><strong>Examples:</strong></p>
<pre><code class="language-yaml"># Extract from captured variable
- shell: "curl https://api.example.com/data"
  capture_output: "api_response"
- shell: "echo 'ID: ${json:$.id:from:api_response}'"

# Extract array element
- shell: "echo 'First item: ${json:$.items[0].name:from:api_response}'"

# Extract nested field
- shell: "echo 'Author: ${json:$.metadata.author:from:config}'"
</code></pre>
<p><strong>Not Cached:</strong> JSON path extraction is fast and not cached.</p>
<p><strong>Requires:</strong> Source variable must contain valid JSON.</p>
<h4 id="date-formatting-date"><a class="header" href="#date-formatting-date">Date Formatting (<code>date:</code>)</a></h4>
<p>Generate current date/time with custom formatting using chrono format specifiers.</p>
<p><strong>Source:</strong> src/cook/execution/variables.rs:278-305</p>
<p><strong>Syntax:</strong> <code>${date:format}</code> (uses chrono format specifiers)</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-yaml"># ISO 8601 date
- shell: "echo 'Report generated: ${date:%Y-%m-%d}'"

# Full timestamp
- shell: "echo 'Build time: ${date:%Y-%m-%d %H:%M:%S}'"

# Custom format
- shell: "mkdir backup-${date:%Y%m%d-%H%M%S}"

# Use in filenames
- shell: "cp logs.txt logs-${date:%Y-%m-%d}.txt"
</code></pre>
<p><strong>Common Format Specifiers:</strong></p>
<ul>
<li><code>%Y</code> - 4-digit year (2025)</li>
<li><code>%m</code> - Month (01-12)</li>
<li><code>%d</code> - Day (01-31)</li>
<li><code>%H</code> - Hour 24h (00-23)</li>
<li><code>%M</code> - Minute (00-59)</li>
<li><code>%S</code> - Second (00-59)</li>
<li><code>%F</code> - ISO 8601 date (2025-01-15)</li>
<li><code>%T</code> - ISO 8601 time (14:30:45)</li>
</ul>
<p><strong>Not Cached:</strong> Date values change over time and are not cached.</p>
<h4 id="uuid-generation-uuid"><a class="header" href="#uuid-generation-uuid">UUID Generation (<code>uuid</code>)</a></h4>
<p>Generate a random UUID version 4. Useful for unique identifiers, temporary filenames, or correlation IDs.</p>
<p><strong>Source:</strong> src/cook/execution/variables.rs:258-276</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-yaml"># Generate unique identifier
- shell: "echo 'Request ID: ${uuid}'"

# Create unique temporary file
- shell: "mkdir /tmp/build-${uuid}"

# Correlation ID for tracking
- shell: "curl -H 'X-Correlation-ID: ${uuid}' https://api.example.com"

# Unique test run ID
- shell: "cargo test -- --test-id ${uuid}"
</code></pre>
<p><strong>Not Cached:</strong> Each <code>${uuid}</code> reference generates a NEW unique UUID. If you need the same UUID multiple times, capture it first:</p>
<pre><code class="language-yaml">- shell: "echo '${uuid}'"
  capture_output: "run_id"
- shell: "echo 'Run ID: ${run_id}'"  # Same UUID
- shell: "echo 'Same ID: ${run_id}'" # Still same UUID
</code></pre>
<h4 id="computed-variable-caching"><a class="header" href="#computed-variable-caching">Computed Variable Caching</a></h4>
<p>Computed variables have different caching behaviors based on their expense and volatility:</p>
<p><strong>Cached (Expensive Operations):</strong></p>
<ul>
<li><code>env.*</code> - Environment variable reads</li>
<li><code>file:*</code> - File system operations</li>
<li><code>cmd:*</code> - Shell command execution</li>
</ul>
<p><strong>Not Cached (Fast or Volatile):</strong></p>
<ul>
<li><code>json:*</code> - JSON parsing is fast</li>
<li><code>date:*</code> - Values change over time</li>
<li><code>uuid</code> - Must be unique each time</li>
</ul>
<p><strong>Cache Details:</strong></p>
<ul>
<li><strong>Type:</strong> LRU (Least Recently Used) cache</li>
<li><strong>Size:</strong> 100 entries maximum</li>
<li><strong>Scope:</strong> Per workflow execution</li>
<li><strong>Thread Safety:</strong> Async RwLock protection</li>
</ul>
<p><strong>Source:</strong> src/cook/execution/variables.rs:218-256 (caching implementation)</p>
<h3 id="workflow-context-variables"><a class="header" href="#workflow-context-variables">Workflow Context Variables</a></h3>
<p>Variables that provide information about the current workflow execution:</p>
<div class="table-wrapper"><table><thead><tr><th>Variable</th><th>Description</th><th>Example</th></tr></thead><tbody>
<tr><td><code>${workflow.name}</code></td><td>Workflow name from YAML config</td><td><code>echo "Running ${workflow.name}"</code></td></tr>
<tr><td><code>${workflow.id}</code></td><td>Unique workflow identifier</td><td><code>log-${workflow.id}.txt</code></td></tr>
<tr><td><code>${workflow.iteration}</code></td><td>Current iteration number (for loops)</td><td><code>Iteration ${workflow.iteration}</code></td></tr>
</tbody></table>
</div>
<p><strong>Available in:</strong> All phases (setup, map, reduce, merge)</p>
<h3 id="step-context-variables"><a class="header" href="#step-context-variables">Step Context Variables</a></h3>
<p>Variables providing information about the current execution step:</p>
<div class="table-wrapper"><table><thead><tr><th>Variable</th><th>Description</th><th>Example</th></tr></thead><tbody>
<tr><td><code>${step.name}</code></td><td>Step name or identifier</td><td><code>echo "Step: ${step.name}"</code></td></tr>
<tr><td><code>${step.index}</code></td><td>Zero-based step index</td><td><code>Step ${step.index} of ${total_steps}</code></td></tr>
</tbody></table>
</div>
<p><strong>Available in:</strong> All phases</p>
<h3 id="item-variables-map-phase-only"><a class="header" href="#item-variables-map-phase-only">Item Variables (Map Phase Only)</a></h3>
<p>Variables for accessing work item data during parallel processing. The <code>${item.*}</code> syntax supports <strong>arbitrary field access</strong> - you can access any field present in your JSON work items, not just the predefined ones shown below.</p>
<p><strong>Source:</strong> src/cook/workflow/variables.rs:16-23 (item variable resolution)</p>
<div class="table-wrapper"><table><thead><tr><th>Variable</th><th>Description</th><th>Example</th></tr></thead><tbody>
<tr><td><code>${item}</code></td><td>Full item object (as string)</td><td><code>echo ${item}</code></td></tr>
<tr><td><code>${item.value}</code></td><td>Item value for simple types</td><td><code>process ${item.value}</code></td></tr>
<tr><td><code>${item.path}</code></td><td>File path (for file inputs)</td><td><code>cat ${item.path}</code></td></tr>
<tr><td><code>${item.name}</code></td><td>Item display name</td><td><code>echo "Processing ${item.name}"</code></td></tr>
<tr><td><code>${item_index}</code></td><td>Zero-based item index</td><td><code>Item ${item_index}</code></td></tr>
<tr><td><code>${item_total}</code></td><td>Total number of items</td><td><code>of ${item_total}</code></td></tr>
<tr><td><code>${item.*}</code></td><td><strong>Any JSON field</strong> - Access arbitrary fields from your work items</td><td><code>${item.priority}</code>, <code>${item.custom_field}</code></td></tr>
</tbody></table>
</div>
<p><strong>Available in:</strong> Map phase only</p>
<h4 id="arbitrary-field-access"><a class="header" href="#arbitrary-field-access">Arbitrary Field Access</a></h4>
<p>The <code>${item.*}</code> syntax provides full access to any field in your JSON work items. This includes:</p>
<ul>
<li><strong>Top-level fields:</strong> <code>${item.priority}</code>, <code>${item.status}</code>, <code>${item.category}</code></li>
<li><strong>Nested fields:</strong> <code>${item.metadata.author}</code>, <code>${item.config.database.host}</code></li>
<li><strong>Array indices:</strong> <code>${item.tags[0]}</code>, <code>${item.dependencies[2].version}</code></li>
<li><strong>Mixed access:</strong> <code>${item.data.results[0].score}</code></li>
</ul>
<p><strong>Example with custom JSON structure:</strong></p>
<pre><code class="language-yaml"># Input: items.json
# [
#   {
#     "file": "src/main.rs",
#     "priority": 10,
#     "owner": "backend-team",
#     "metadata": {
#       "last_modified": "2025-01-10",
#       "reviewer": "alice"
#     },
#     "tags": ["critical", "security"]
#   }
# ]

map:
  input: "items.json"
  json_path: "$[*]"
  agent_template:
    # Access any field from your JSON structure
    - shell: "echo 'Processing ${item.file}'"
    - shell: "echo 'Priority: ${item.priority}'"
    - shell: "echo 'Owner: ${item.owner}'"
    - shell: "echo 'Reviewer: ${item.metadata.reviewer}'"
    - shell: "echo 'First tag: ${item.tags[0]}'"
    - claude: "/analyze '${item.file}' --priority ${item.priority} --owner ${item.owner}"
</code></pre>
<p><strong>Best Practice:</strong> Use descriptive field names in your JSON work items - they become your variable names.</p>
<h3 id="mapreduce-variables-reduce-phase-only"><a class="header" href="#mapreduce-variables-reduce-phase-only">MapReduce Variables (Reduce Phase Only)</a></h3>
<p>Variables for accessing aggregated results from map phase. Map results support <strong>indexed access</strong> for retrieving individual agent results and <strong>nested field access</strong> for extracting specific properties.</p>
<p><strong>Source:</strong> src/cook/execution/mapreduce/utils.rs:119-121, src/cook/execution/mapreduce/reduce_phase.rs:146</p>
<div class="table-wrapper"><table><thead><tr><th>Variable</th><th>Description</th><th>Example</th></tr></thead><tbody>
<tr><td><code>${map.total}</code></td><td>Total items in map phase</td><td><code>echo "Processed ${map.total} items"</code></td></tr>
<tr><td><code>${map.successful}</code></td><td>Successfully processed items</td><td><code>echo "${map.successful} succeeded"</code></td></tr>
<tr><td><code>${map.failed}</code></td><td>Failed items count</td><td><code>echo "${map.failed} failed"</code></td></tr>
<tr><td><code>${map.results}</code></td><td>All map results as JSON array</td><td><code>echo '${map.results}' | jq</code></td></tr>
<tr><td><code>${map.results_json}</code></td><td>Alias for <code>map.results</code> (same value)</td><td><code>echo '${map.results_json}' | jq</code></td></tr>
<tr><td><code>${map.results[index]}</code></td><td>Individual result by index (0-based)</td><td><code>${map.results[0]}</code>, <code>${map.results[5]}</code></td></tr>
<tr><td><code>${map.results[index].field}</code></td><td>Nested field access</td><td><code>${map.results[0].output}</code>, <code>${map.results[2].item_id}</code></td></tr>
<tr><td><code>${map.key}</code></td><td>Key for map output (optional)</td><td><code>${map.key}</code></td></tr>
<tr><td><code>${worker.id}</code></td><td>Worker ID for tracking</td><td><code>Worker ${worker.id}</code></td></tr>
</tbody></table>
</div>
<p><strong>Available in:</strong> Reduce phase only</p>
<h4 id="indexed-access-to-map-results"><a class="header" href="#indexed-access-to-map-results">Indexed Access to Map Results</a></h4>
<p>You can access individual agent results using bracket notation <code>[index]</code> and drill into nested fields with dot notation.</p>
<p><strong>Syntax patterns:</strong></p>
<ul>
<li><code>${map.results[0]}</code> - First agent result (full object)</li>
<li><code>${map.results[0].output}</code> - Output from first agent</li>
<li><code>${map.results[0].item_id}</code> - Item ID processed by first agent</li>
<li><code>${map.results[0].success}</code> - Success status (“true” or “false”)</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-yaml">reduce:
  # Access specific agent results
  - shell: "echo 'First result: ${map.results[0]}'"
  - shell: "echo 'First output: ${map.results[0].output}'"
  - shell: "echo 'Second agent processed: ${map.results[1].item_id}'"

  # Combine with shell commands
  - shell: |
      if [ "${map.results[0].success}" = "true" ]; then
        echo "First agent succeeded"
      fi

  # Process multiple results
  - shell: |
      echo "Results 0-2:"
      echo "${map.results[0].item_id}"
      echo "${map.results[1].item_id}"
      echo "${map.results[2].item_id}"
</code></pre>
<h4 id="full-array-processing"><a class="header" href="#full-array-processing">Full Array Processing</a></h4>
<p>For processing all results, use <code>${map.results}</code> with JSON tools like <code>jq</code>:</p>
<pre><code class="language-yaml">reduce:
  # Count errors using jq
  - shell: |
      echo '${map.results}' | jq '[.[] | select(.status == "error")] | length'
    capture_output: "error_count"

  # Extract all item IDs
  - shell: |
      echo '${map.results}' | jq -r '.[].item_id'
    capture_output: "processed_items"

  # Calculate average score
  - shell: |
      echo '${map.results}' | jq '[.[].score] | add / length'
    capture_output: "avg_score"

  # Filter successful results
  - shell: |
      echo '${map.results}' | jq '[.[] | select(.success == true)]'
    capture_output: "successful_results"

  # Generate summary
  - claude: "/summarize ${map.results} --total ${map.total} --failed ${map.failed}"
</code></pre>
<p><strong>Note:</strong> <code>${map.results}</code> and <code>${map.results_json}</code> are equivalent - use whichever is clearer in your context.</p>
<h3 id="git-context-variables"><a class="header" href="#git-context-variables">Git Context Variables</a></h3>
<p>Variables tracking git changes throughout workflow execution:</p>
<div class="table-wrapper"><table><thead><tr><th>Variable</th><th>Description</th><th>Example</th></tr></thead><tbody>
<tr><td><code>${step.files_added}</code></td><td>Files added in current step</td><td><code>echo ${step.files_added}</code></td></tr>
<tr><td><code>${step.files_modified}</code></td><td>Files modified in current step</td><td><code>echo ${step.files_modified}</code></td></tr>
<tr><td><code>${step.files_deleted}</code></td><td>Files deleted in current step</td><td><code>echo ${step.files_deleted}</code></td></tr>
<tr><td><code>${step.files_changed}</code></td><td>All changed files (added + modified + deleted)</td><td><code>echo ${step.files_changed}</code></td></tr>
<tr><td><code>${step.commits}</code></td><td>Commits in current step</td><td><code>echo ${step.commits}</code></td></tr>
<tr><td><code>${step.commit_count}</code></td><td>Number of commits in step</td><td><code>echo "${step.commit_count} commits"</code></td></tr>
<tr><td><code>${step.insertions}</code></td><td>Lines inserted in step</td><td><code>echo "+${step.insertions}"</code></td></tr>
<tr><td><code>${step.deletions}</code></td><td>Lines deleted in step</td><td><code>echo "-${step.deletions}"</code></td></tr>
<tr><td><code>${workflow.commits}</code></td><td>All commits in workflow</td><td><code>git show ${workflow.commits}</code></td></tr>
<tr><td><code>${workflow.commit_count}</code></td><td>Total number of commits</td><td><code>echo "${workflow.commit_count} commits"</code></td></tr>
</tbody></table>
</div>
<p><strong>Available in:</strong> All phases (requires git repository)</p>
<h4 id="format-modifiers"><a class="header" href="#format-modifiers">Format Modifiers</a></h4>
<p><strong>Important:</strong> These format modifiers work with <strong>all git context variables that return file or commit lists</strong>, not just the examples shown. Apply them to any of: <code>step.files_added</code>, <code>step.files_modified</code>, <code>step.files_deleted</code>, <code>step.files_changed</code>, <code>step.commits</code>, <code>workflow.commits</code>, and merge phase git variables.</p>
<p>Git context variables support multiple output formats:</p>
<div class="table-wrapper"><table><thead><tr><th>Modifier</th><th>Description</th><th>Example</th></tr></thead><tbody>
<tr><td>(default)</td><td>Space-separated list</td><td><code>${step.files_added}</code> → <code>file1.rs file2.rs</code></td></tr>
<tr><td><code>:json</code></td><td>JSON array format</td><td><code>${step.files_added:json}</code> → <code>["file1.rs", "file2.rs"]</code></td></tr>
<tr><td><code>:lines</code></td><td>Newline-separated list</td><td><code>${step.files_added:lines}</code> → <code>file1.rs\nfile2.rs</code></td></tr>
<tr><td><code>:csv</code></td><td>Comma-separated list</td><td><code>${step.files_added:csv}</code> → <code>file1.rs,file2.rs</code></td></tr>
<tr><td><code>:*.ext</code></td><td>Glob pattern filter</td><td><code>${step.files_added:*.rs}</code> → only Rust files</td></tr>
<tr><td><code>:path/**/*.ext</code></td><td>Path with glob</td><td><code>${step.files_added:src/**/*.rs}</code> → Rust files in src/</td></tr>
</tbody></table>
</div>
<p><strong>Format Examples:</strong></p>
<pre><code class="language-yaml"># JSON format for jq processing
- shell: "echo '${step.files_added:json}' | jq -r '.[]'"

# Newline format for iteration
- shell: |
    echo '${step.files_modified:lines}' | while read file; do
      cargo fmt "$file"
    done

# Glob filtering for language-specific operations
- shell: "cargo clippy ${step.files_modified:*.rs}"

# Multiple glob patterns
- shell: "git diff ${step.files_modified:*.rs,*.toml}"
</code></pre>
<h3 id="merge-variables-merge-phase-only"><a class="header" href="#merge-variables-merge-phase-only">Merge Variables (Merge Phase Only)</a></h3>
<p>Variables available during the merge phase when integrating worktree changes. Merge variables include both basic context and comprehensive git tracking information.</p>
<p><strong>Source:</strong> src/worktree/merge_orchestrator.rs:340-423</p>
<h4 id="basic-merge-context"><a class="header" href="#basic-merge-context">Basic Merge Context</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Variable</th><th>Description</th><th>Example</th></tr></thead><tbody>
<tr><td><code>${merge.worktree}</code></td><td>Worktree name being merged</td><td><code>echo ${merge.worktree}</code></td></tr>
<tr><td><code>${merge.source_branch}</code></td><td>Source branch from worktree</td><td><code>git log ${merge.source_branch}</code></td></tr>
<tr><td><code>${merge.target_branch}</code></td><td>Target branch (where you started)</td><td><code>git merge ${merge.source_branch}</code></td></tr>
<tr><td><code>${merge.session_id}</code></td><td>Session ID for correlation</td><td><code>echo ${merge.session_id}</code></td></tr>
</tbody></table>
</div>
<h4 id="merge-git-context-variables"><a class="header" href="#merge-git-context-variables">Merge Git Context Variables</a></h4>
<p>Additional variables tracking git changes during the merge operation:</p>
<div class="table-wrapper"><table><thead><tr><th>Variable</th><th>Description</th><th>Format</th><th>Example</th></tr></thead><tbody>
<tr><td><code>${merge.commits}</code></td><td>All commits from worktree</td><td>JSON array</td><td><code>echo '${merge.commits}' | jq</code></td></tr>
<tr><td><code>${merge.commit_count}</code></td><td>Number of commits</td><td>Integer</td><td><code>echo "${merge.commit_count} commits"</code></td></tr>
<tr><td><code>${merge.commit_ids}</code></td><td>Short commit IDs</td><td>Comma-separated</td><td><code>git show ${merge.commit_ids}</code></td></tr>
<tr><td><code>${merge.modified_files}</code></td><td>Modified files with metadata</td><td>JSON array</td><td><code>echo '${merge.modified_files}' | jq</code></td></tr>
<tr><td><code>${merge.file_count}</code></td><td>Number of modified files</td><td>Integer</td><td><code>echo "${merge.file_count} files"</code></td></tr>
<tr><td><code>${merge.file_list}</code></td><td>File paths</td><td>Comma-separated</td><td><code>echo ${merge.file_list}</code></td></tr>
</tbody></table>
</div>
<p><strong>Available in:</strong> Merge phase only</p>
<p><strong>Limits:</strong> Capped at 100 commits and 500 files to prevent overwhelming workflows (configurable in GitOperationsConfig).</p>
<h4 id="merge-context-examples"><a class="header" href="#merge-context-examples">Merge Context Examples</a></h4>
<p><strong>Basic merge workflow:</strong></p>
<pre><code class="language-yaml">merge:
  commands:
    - shell: "git fetch origin"
    - shell: "git merge origin/${merge.target_branch}"
    - claude: "/prodigy-merge-worktree ${merge.source_branch} ${merge.target_branch}"
</code></pre>
<p><strong>Using git context variables:</strong></p>
<pre><code class="language-yaml">merge:
  commands:
    # Show merge summary
    - shell: |
        echo "Merging worktree: ${merge.worktree}"
        echo "Commits: ${merge.commit_count}"
        echo "Files modified: ${merge.file_count}"

    # List all commits being merged
    - shell: "echo 'Commit IDs: ${merge.commit_ids}'"

    # Process commits as JSON
    - shell: |
        echo '${merge.commits}' | jq -r '.[] | "\(.short_id): \(.message)"'

    # Check specific files
    - shell: |
        echo '${merge.modified_files}' | jq -r '.[].path'

    # Conditional merge based on file count
    - shell: |
        if [ ${merge.file_count} -gt 50 ]; then
          echo "Large merge detected, requesting review"
        fi

    # Perform merge
    - claude: "/prodigy-merge-worktree ${merge.source_branch} ${merge.target_branch}"
</code></pre>
<h4 id="commit-object-structure"><a class="header" href="#commit-object-structure">Commit Object Structure</a></h4>
<p>The <code>${merge.commits}</code> variable contains an array of commit objects with this structure:</p>
<pre><code class="language-json">[
  {
    "id": "full-sha-hash",
    "short_id": "abc1234",
    "author": {
      "name": "Author Name",
      "email": "author@example.com"
    },
    "message": "Commit message",
    "timestamp": "2025-01-10T12:00:00Z",
    "files_changed": ["file1.rs", "file2.rs"]
  }
]
</code></pre>
<p><strong>Source:</strong> src/cook/execution/mapreduce/resources/git_operations.rs:280-293</p>
<h4 id="file-object-structure"><a class="header" href="#file-object-structure">File Object Structure</a></h4>
<p>The <code>${merge.modified_files}</code> variable contains an array of file modification objects:</p>
<pre><code class="language-json">[
  {
    "path": "src/main.rs",
    "modification_type": "Modified",
    "size_before": 1024,
    "size_after": 1156,
    "last_modified": "2025-01-10T12:00:00Z",
    "commit_id": "abc1234"
  }
]
</code></pre>
<p><strong>Source:</strong> src/cook/execution/mapreduce/resources/git_operations.rs:311-322</p>
<h3 id="validation-variables"><a class="header" href="#validation-variables">Validation Variables</a></h3>
<p>Variables for workflow validation and completion tracking:</p>
<div class="table-wrapper"><table><thead><tr><th>Variable</th><th>Description</th><th>Example</th></tr></thead><tbody>
<tr><td><code>${validation.completion}</code></td><td>Completion percentage (0-100)</td><td><code>echo "${validation.completion}%"</code></td></tr>
<tr><td><code>${validation.gaps}</code></td><td>Array of missing requirements</td><td><code>echo '${validation.gaps}'</code></td></tr>
<tr><td><code>${validation.status}</code></td><td>Status: complete/incomplete/failed</td><td><code>if [ "${validation.status}" = "complete" ]</code></td></tr>
</tbody></table>
</div>
<p><strong>Available in:</strong> Goal seek and validation phases</p>
<h3 id="variable-interpolation-syntax"><a class="header" href="#variable-interpolation-syntax">Variable Interpolation Syntax</a></h3>
<p>Prodigy supports two interpolation syntaxes:</p>
<ul>
<li><strong><code>${VAR}</code></strong> - Preferred syntax, works in all contexts (recommended)</li>
<li><strong><code>$VAR</code></strong> - Shell-style syntax, simpler but may have limitations</li>
</ul>
<p><strong>When to use <code>${VAR}</code>:</strong></p>
<ul>
<li>In YAML values with special characters</li>
<li>For nested field access: <code>${item.nested.field}</code></li>
<li>When combining with text: <code>prefix_${var}_suffix</code></li>
<li>For format modifiers: <code>${step.files:json}</code></li>
</ul>
<p><strong>When <code>$VAR</code> works:</strong></p>
<ul>
<li>Simple variable names in shell commands</li>
<li>Environment variables in shell context</li>
<li>Quick substitutions without special characters</li>
</ul>
<p><strong>Best Practice:</strong> Always use <code>${VAR}</code> syntax for consistency and reliability.</p>
<h3 id="legacy-variable-aliases"><a class="header" href="#legacy-variable-aliases">Legacy Variable Aliases</a></h3>
<p>For backward compatibility, Prodigy supports legacy variable aliases from earlier versions. These are still functional but <strong>deprecated</strong> - prefer the current variable names in new workflows.</p>
<p><strong>Source:</strong> src/cook/workflow/variables.rs (legacy alias definitions)</p>
<div class="table-wrapper"><table><thead><tr><th>Legacy Alias</th><th>Current Variable</th><th>Context</th><th>Status</th></tr></thead><tbody>
<tr><td><code>${ARG}</code></td><td><code>${item.value}</code></td><td>Map phase</td><td>Deprecated</td></tr>
<tr><td><code>${ARGUMENT}</code></td><td><code>${item.value}</code></td><td>Map phase</td><td>Deprecated</td></tr>
<tr><td><code>${FILE}</code></td><td><code>${item.path}</code></td><td>Map phase</td><td>Deprecated</td></tr>
<tr><td><code>${FILE_PATH}</code></td><td><code>${item.path}</code></td><td>Map phase</td><td>Deprecated</td></tr>
</tbody></table>
</div>
<p><strong>Example:</strong></p>
<pre><code class="language-yaml"># Old style (still works but discouraged)
map:
  agent_template:
    - shell: "process ${ARG}"
    - shell: "cat ${FILE}"

# New style (recommended)
map:
  agent_template:
    - shell: "process ${item.value}"
    - shell: "cat ${item.path}"
</code></pre>
<p><strong>Migration Recommendation:</strong> Update legacy aliases to current variable names when maintaining older workflows. The current names are more explicit and work better with arbitrary JSON field access.</p>
<h4 id="default-values"><a class="header" href="#default-values">Default Values</a></h4>
<p>Provide fallback values for undefined or missing variables using the <code>:-</code> syntax (bash/shell convention):</p>
<p><strong>Syntax:</strong> <code>${variable:-default_value}</code></p>
<p><strong>Source:</strong> src/cook/execution/interpolation.rs:277</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-yaml"># Use default if variable is undefined
- shell: "echo 'Timeout: ${timeout:-600}'"
  # Output: "Timeout: 600" if timeout is not defined

# Fallback for optional configuration
- shell: "cargo build --profile ${build_profile:-dev}"
  # Uses "dev" profile if build_profile not set

# Default for MapReduce variables
- shell: "echo 'Processed ${map.successful:-0} items'"
  # Shows "0" if map.successful is not available
</code></pre>
<p><strong>Behavior with Interpolation Modes:</strong></p>
<ul>
<li><strong>Non-strict mode (default):</strong> Uses default value if variable is undefined</li>
<li><strong>Strict mode:</strong> Default value syntax prevents errors for optional variables</li>
</ul>
<h4 id="interpolation-modes"><a class="header" href="#interpolation-modes">Interpolation Modes</a></h4>
<p>Prodigy supports two modes for handling undefined variables:</p>
<p><strong>Non-strict Mode (Default):</strong></p>
<ul>
<li>Leaves placeholders unresolved when variable is undefined</li>
<li>Example: <code>${undefined}</code> remains as <code>${undefined}</code> in output</li>
<li>With default: <code>${undefined:-fallback}</code> becomes <code>fallback</code></li>
<li>Use case: Workflows that can handle partial variable resolution</li>
</ul>
<p><strong>Strict Mode:</strong></p>
<ul>
<li>Fails immediately on undefined variables</li>
<li>Example: <code>${undefined}</code> causes workflow to fail with comprehensive error</li>
<li>Error message lists all available variables for debugging</li>
<li>Use case: Production workflows requiring all variables to be properly defined</li>
</ul>
<p><strong>Source:</strong> src/cook/execution/interpolation.rs:16-17, 104-137</p>
<p><strong>Configuration:</strong>
Strict mode is configured per InterpolationEngine instance and controlled at the workflow execution level.</p>
<p><strong>Best Practice:</strong> Use strict mode during development to catch variable name typos and scope issues early. Use default values (<code>${var:-default}</code>) for truly optional configuration.</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-yaml"># Non-strict mode (graceful degradation)
- shell: "echo 'Config: ${optional_config:-none}'"
  # Works even if optional_config is undefined

# Strict mode (fail fast)
# If required_var is undefined, workflow stops with error:
# "Variable interpolation failed: required_var not found.
#  Available variables: workflow.name, workflow.id, step.index, ..."
- shell: "echo 'Required: ${required_var}'"
</code></pre>
<h3 id="variable-scoping-and-precedence"><a class="header" href="#variable-scoping-and-precedence">Variable Scoping and Precedence</a></h3>
<h4 id="scope-by-phase"><a class="header" href="#scope-by-phase">Scope by Phase</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Phase</th><th>Variables Available</th></tr></thead><tbody>
<tr><td>Setup</td><td>Standard, workflow context, step context, git context, custom captured</td></tr>
<tr><td>Map</td><td>Standard, workflow context, step context, git context, item variables, custom captured</td></tr>
<tr><td>Reduce</td><td>Standard, workflow context, step context, git context, MapReduce variables, custom captured</td></tr>
<tr><td>Merge</td><td>Standard, workflow context, step context, merge variables, custom captured</td></tr>
</tbody></table>
</div>
<p><strong>Important:</strong> Setup phase captures are available in map and reduce phases. Map phase captures are only available within that specific agent. Reduce phase captures are available to subsequent reduce steps.</p>
<h4 id="variable-precedence-highest-to-lowest"><a class="header" href="#variable-precedence-highest-to-lowest">Variable Precedence (highest to lowest)</a></h4>
<ol>
<li><strong>Custom captured variables</strong> (<code>capture_output</code>)</li>
<li><strong>Phase-specific built-in variables</strong> (<code>item.*</code>, <code>map.*</code>, <code>merge.*</code>)</li>
<li><strong>Step context variables</strong> (<code>step.*</code>)</li>
<li><strong>Workflow context variables</strong> (<code>workflow.*</code>)</li>
<li><strong>Standard output variables</strong> (<code>last.output</code>, <code>shell.output</code>)</li>
<li><strong>Environment variables</strong> (static workflow-level <code>env</code> block)</li>
<li><strong>Computed variables</strong> (<code>env.*</code>, <code>file:*</code>, <code>cmd:*</code>, <code>json:*</code>, <code>date:*</code>, <code>uuid</code>)</li>
</ol>
<p><strong>Note:</strong> Computed variables have lowest precedence because they’re evaluated on-demand. If a custom variable has the same name as a computed variable, the custom variable wins.</p>
<p><strong>Shadowing Warning:</strong> Custom captures can shadow built-in variable names. Avoid using names like <code>item</code>, <code>map</code>, <code>workflow</code>, etc. as custom variable names.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-yaml"># Bad: shadows built-in ${item}
- shell: "custom command"
  capture_output: "item"  # Don't do this!

# Good: descriptive custom name
- shell: "custom command"
  capture_output: "custom_result"
</code></pre>
<h4 id="parent-context-resolution"><a class="header" href="#parent-context-resolution">Parent Context Resolution</a></h4>
<p>Variable resolution walks up a parent context chain when variables are not found in the current context. This enables variable inheritance across workflow phases and nested contexts.</p>
<p><strong>Source:</strong> src/cook/execution/interpolation.rs:200-226, InterpolationContext struct at :376-381</p>
<p><strong>Resolution Order:</strong></p>
<ol>
<li>Check current context</li>
<li>If not found, check parent context</li>
<li>If not found in parent, check parent’s parent</li>
<li>Continue until variable is found or no parent exists</li>
<li>If not found and has default value, use default</li>
<li>If not found in strict mode, fail with error listing available variables</li>
</ol>
<p><strong>Benefits:</strong></p>
<ul>
<li>Nested workflow contexts inherit variables from parent workflows</li>
<li>Foreach loops access both loop-level and workflow-level variables</li>
<li>Map agents access setup phase variables</li>
<li>Reduce phase accesses both map results and setup variables</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-yaml">setup:
  - shell: "pwd"
    capture_output: "workspace_root"  # Available to all agents via parent context
  - shell: "git rev-parse HEAD"
    capture_output: "base_commit"     # Also inherited by map agents

map:
  input: "items.json"
  json_path: "$.items[*]"
  agent_template:
    - shell: "echo 'processing ${item.name}'"
      capture_output: "item_status"  # Only in this agent's context
    - shell: "cd ${workspace_root}"  # Resolved from parent (setup) context
    - shell: "git diff ${base_commit}" # Also from parent context
    - shell: "echo 'Status: ${item_status}'" # From current agent context

reduce:
  # Can access setup variables but NOT individual agent's item_status
  - shell: "cd ${workspace_root}"  # From setup phase parent context
  - shell: "echo 'Base: ${base_commit}'"  # Also from setup phase
</code></pre>
<p><strong>Context Hierarchy:</strong></p>
<pre><code>Setup Context (workspace_root, base_commit)
    ↓ parent
Map Agent Context (item, item_status, workspace_root*, base_commit*)
    ↓ parent
Reduce Context (map.results, workspace_root*, base_commit*)
</code></pre>
<p>*Inherited from parent context</p>
<h3 id="reduce-phase-access-to-item-data"><a class="header" href="#reduce-phase-access-to-item-data">Reduce Phase Access to Item Data</a></h3>
<p>In the reduce phase, individual item variables (<code>${item.*}</code>) are not directly available, but you can access all item data through <code>${map.results}</code>, which contains the aggregated results from all map agents.</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-yaml">reduce:
  # Count items with specific property
  - shell: |
      echo '${map.results}' | jq '[.[] | select(.type == "error")] | length'
    capture_output: "error_count"

  # Extract all file paths processed
  - shell: |
      echo '${map.results}' | jq -r '.[].item.path'
    capture_output: "all_paths"

  # Aggregate numeric field
  - shell: |
      echo '${map.results}' | jq '[.[].coverage] | add / length'
    capture_output: "avg_coverage"

  # Filter and transform results
  - shell: |
      echo '${map.results}' | jq '[.[] | select(.item.priority &gt; 5) | .item.name]'
    capture_output: "high_priority_items"
</code></pre>
<h3 id="performance-template-caching"><a class="header" href="#performance-template-caching">Performance: Template Caching</a></h3>
<p>Prodigy implements <strong>dual caching</strong> for optimal performance: template parsing cache and operation result cache.</p>
<p><strong>Source:</strong> src/cook/execution/interpolation.rs:18-19, 68-75; src/cook/execution/variables.rs:218-256</p>
<h4 id="template-parse-caching"><a class="header" href="#template-parse-caching">Template Parse Caching</a></h4>
<p>When the same variable template is used multiple times, the template is parsed once and reused:</p>
<p><strong>How It Works:</strong></p>
<ul>
<li>First use: Template is parsed and cached</li>
<li>Subsequent uses: Cached template is reused (no re-parsing)</li>
<li>Cache key: Exact template string</li>
<li>Automatic: No configuration needed</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-yaml"># Template "${item.path} --priority ${item.metadata.priority:-5}"
# is parsed once, then reused for all 1000 items
map:
  input: "items.json"  # 1000 items
  json_path: "$.items[*]"
  agent_template:
    - shell: "process ${item.path} --priority ${item.metadata.priority:-5}"
</code></pre>
<h4 id="computed-variable-caching-1"><a class="header" href="#computed-variable-caching-1">Computed Variable Caching</a></h4>
<p>Expensive computed operations (file reads, command execution) have separate result caching:</p>
<p><strong>Cached Operations:</strong></p>
<ul>
<li><code>${env.VAR}</code> - Environment variable lookups</li>
<li><code>${file:path}</code> - File system reads</li>
<li><code>${cmd:command}</code> - Shell command execution</li>
</ul>
<p><strong>Not Cached:</strong></p>
<ul>
<li><code>${json:path:from:var}</code> - JSON parsing is fast</li>
<li><code>${date:format}</code> - Values change over time</li>
<li><code>${uuid}</code> - Must be unique</li>
</ul>
<p><strong>Cache Details:</strong></p>
<ul>
<li><strong>Type:</strong> LRU (Least Recently Used) cache</li>
<li><strong>Size:</strong> 100 entries maximum</li>
<li><strong>Scope:</strong> Per workflow execution</li>
<li><strong>Thread Safety:</strong> Async RwLock protection</li>
</ul>
<p><strong>Performance Impact:</strong></p>
<pre><code class="language-yaml"># First shell command: Reads .commit-message.txt from disk
- shell: "git commit -m '${file:.commit-message.txt}'"

# Second shell command: Uses cached file content (no disk read)
- shell: "echo 'Message: ${file:.commit-message.txt}'"

# Third shell command: Still uses cache
- shell: "test -n '${file:.commit-message.txt}'"
</code></pre>
<p><strong>Benefits:</strong></p>
<ul>
<li><strong>Faster interpolation</strong> for repeated templates (template cache)</li>
<li><strong>Reduced I/O</strong> for repeated file reads (operation cache)</li>
<li><strong>Lower CPU</strong> for repeated command execution (operation cache)</li>
<li><strong>Reduced latency</strong> in MapReduce workflows</li>
</ul>
<p><strong>When It Matters Most:</strong></p>
<ul>
<li>MapReduce workflows with many work items (&gt;100)</li>
<li>Workflows using the same computed variables repeatedly</li>
<li>High-frequency variable interpolation in loops</li>
<li>Templates with multiple variables and nested field access</li>
</ul>
<p><strong>Note:</strong> All caching is transparent and automatic. You don’t need any configuration to benefit from it. Both caches persist for the lifetime of the workflow execution.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../variables/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../variables/custom-variable-capture.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../variables/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../variables/custom-variable-capture.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
