# Example workflow demonstrating per-step analysis configuration
# This workflow shows how to control when analysis runs
# Analysis always includes both metrics and context data

# First command: Implement a spec
# This uses the initial analysis from workflow start
- claude: "/prodigy-implement-spec $ARG"
  commit_required: true
  # No analysis configuration - uses initial context

# Second command: Run linting
# Linting typically doesn't need metrics data
- claude: "/prodigy-lint"
  commit_required: false
  # No analysis needed - works with existing code structure

# Third command: Code review
# This command benefits from fresh analysis
- analyze:
    max_cache_age: 300        # Use cache if less than 5 minutes old
    force_refresh: false      # Don't force if cache is fresh
    save: true
    format: "summary"

- claude: "/prodigy-code-review"

# Fourth command: Clean up technical debt
# This needs fresh analysis to prioritize cleanup
- analyze:
    force_refresh: true       # Always get fresh analysis for accuracy
    save: true
    format: "summary"

- claude: "/prodigy-cleanup-tech-debt"

# Fifth command: Generate documentation
# This needs updated analysis after all changes
- analyze:
    max_cache_age: 60         # Very short cache - 1 minute
    force_refresh: false      # Use cache if available and fresh
    save: true
    format: "summary"

- claude: "/prodigy-generate-docs"

# Usage examples:
# 
# Run with a single spec:
#   prodigy cook -p analysis-workflow.yml --args 45
#
# Run with multiple specs:
#   prodigy cook -p analysis-workflow.yml --map "specs/*.md"
#
# Skip initial analysis (if commands have their own):
#   prodigy cook -p analysis-workflow.yml --skip-analysis
#
# Force metrics for all commands:
#   prodigy cook -p analysis-workflow.yml --metrics