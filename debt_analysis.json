============================================
    Debtmap v0.2.3
============================================

[TARGET] TOP 10 RECOMMENDATIONS

#1 SCORE: 1769 [CRITICAL - FILE AGGREGATE]
├─ ./src/cook/execution/mapreduce.rs (25 functions, total score: 1769.2)
├─ WHY: File aggregate combines complexity scores from 25 individual functions to identify files with widespread technical debt. Unlike single file-level issues (god objects, high line count), this represents accumulated complexity across multiple functions. 25 functions exceed complexity thresholds.
├─ ACTION: Focus on the top 2 high-complexity functions listed below (complexity > 10 or coverage < 60%)
│  ├─ 1. Start with these 2 functions (listed in DEPENDENCIES below)
│  ├─ 2. For each function: If coverage < 60%, add tests for uncovered lines ONLY
│  ├─ 3. For each function: If complexity > 10, apply these patterns:
│  │   • Extract guard clauses: Convert nested if-else to early returns
│  │   • Extract validation: Move input checks to separate function
│  │   • Replace conditionals with map/filter when processing collections
│  │   • Extract complex boolean expressions into named predicates
│  └─ 4. Keep refactoring focused: Extract helpers as needed, but avoid over-engineering
├─ IMPACT: Reduce overall file complexity by 100%, improve test coverage, enable safer refactoring
├─ METRICS: Functions: 25, Problematic: 25, Avg complexity: 70.8
├─ SCORING: Aggregate: CRITICAL | Avg per function: 70.8 | Max: 82.2
└─ DEPS: 25 high-complexity functions identified
   ├─ MapReduceExecutor::execute_reduce_phase: 82.2
   ├─ MapReduceExecutor::execute_with_context: 82.0
   ├─ MapReduceExecutor::find_missing_variables: 80.9
   ├─ MapReduceExecutor::resume_job_with_options: 80.2
   └─ MapReduceExecutor::collect_command_types: 79.4

#2 SCORE: 1718 [CRITICAL - FILE AGGREGATE]
├─ ./src/cook/workflow/executor.rs (24 functions, total score: 1753.3)
├─ WHY: File aggregate combines complexity scores from 24 individual functions to identify files with widespread technical debt. Unlike single file-level issues (god objects, high line count), this represents accumulated complexity across multiple functions. 24 functions exceed complexity thresholds.
├─ ACTION: Focus on the top 2 high-complexity functions listed below (complexity > 10 or coverage < 60%)
│  ├─ 1. Start with these 2 functions (listed in DEPENDENCIES below)
│  ├─ 2. For each function: If coverage < 60%, add tests for uncovered lines ONLY
│  ├─ 3. For each function: If complexity > 10, apply these patterns:
│  │   • Extract guard clauses: Convert nested if-else to early returns
│  │   • Extract validation: Move input checks to separate function
│  │   • Replace conditionals with map/filter when processing collections
│  │   • Extract complex boolean expressions into named predicates
│  └─ 4. Keep refactoring focused: Extract helpers as needed, but avoid over-engineering
├─ IMPACT: Reduce overall file complexity by 100%, improve test coverage, enable safer refactoring
├─ METRICS: Functions: 24, Problematic: 24, Avg complexity: 73.1
├─ SCORING: Aggregate: CRITICAL | Avg per function: 71.6 | Max: 82.2
└─ DEPS: 24 high-complexity functions identified
   ├─ WorkflowExecutor::execute_shell_with_retry: 82.2
   ├─ WorkflowExecutor::execute_test_command: 82.2
   ├─ WorkflowExecutor::handle_on_failure: 82.1
   ├─ WorkflowExecutor::execute_mapreduce: 81.3
   └─ WorkflowExecutor::execute: 81.3

#3 SCORE: 878 [CRITICAL - FILE AGGREGATE]
├─ ./src/cli/events.rs (16 functions, total score: 1097.7)
├─ WHY: File aggregate combines complexity scores from 16 individual functions to identify files with widespread technical debt. Unlike single file-level issues (god objects, high line count), this represents accumulated complexity across multiple functions. 16 functions exceed complexity thresholds.
├─ ACTION: Focus on the top 2 high-complexity functions listed below (complexity > 10 or coverage < 60%)
│  ├─ 1. Start with these 2 functions (listed in DEPENDENCIES below)
│  ├─ 2. For each function: If coverage < 60%, add tests for uncovered lines ONLY
│  ├─ 3. For each function: If complexity > 10, apply these patterns:
│  │   • Extract guard clauses: Convert nested if-else to early returns
│  │   • Extract validation: Move input checks to separate function
│  │   • Replace conditionals with map/filter when processing collections
│  │   • Extract complex boolean expressions into named predicates
│  └─ 4. Keep refactoring focused: Extract helpers as needed, but avoid over-engineering
├─ IMPACT: Reduce overall file complexity by 100%, improve test coverage, enable safer refactoring
├─ METRICS: Functions: 16, Problematic: 16, Avg complexity: 68.6
├─ SCORING: Aggregate: CRITICAL | Avg per function: 54.9 | Max: 87.7
└─ DEPS: 16 high-complexity functions identified
   ├─ get_event_type: 87.7
   ├─ follow_events: 82.1
   ├─ list_events: 79.6
   ├─ search_aggregated_events: 79.2
   └─ process_event_for_status: 77.7

#4 SCORE: 600 [CRITICAL - FILE AGGREGATE]
├─ ./src/main.rs (12 functions, total score: 866.4)
├─ WHY: File aggregate combines complexity scores from 12 individual functions to identify files with widespread technical debt. Unlike single file-level issues (god objects, high line count), this represents accumulated complexity across multiple functions. 12 functions exceed complexity thresholds.
├─ ACTION: Focus on the top 2 high-complexity functions listed below (complexity > 10 or coverage < 60%)
│  ├─ 1. Start with these 2 functions (listed in DEPENDENCIES below)
│  ├─ 2. For each function: If coverage < 60%, add tests for uncovered lines ONLY
│  ├─ 3. For each function: If complexity > 10, apply these patterns:
│  │   • Extract guard clauses: Convert nested if-else to early returns
│  │   • Extract validation: Move input checks to separate function
│  │   • Replace conditionals with map/filter when processing collections
│  │   • Extract complex boolean expressions into named predicates
│  └─ 4. Keep refactoring focused: Extract helpers as needed, but avoid over-engineering
├─ IMPACT: Reduce overall file complexity by 100%, improve test coverage, enable safer refactoring
├─ METRICS: Functions: 12, Problematic: 12, Avg complexity: 72.2
├─ SCORING: Aggregate: CRITICAL | Avg per function: 50.0 | Max: 82.1
└─ DEPS: 12 high-complexity functions identified
   ├─ run_resume_workflow: 82.1
   ├─ run_sessions_command: 82.0
   ├─ handle_single_cleanup: 75.2
   ├─ resolve_job_id: 74.2
   └─ merge_single_session: 72.2

#5 SCORE: 539 [CRITICAL - FILE AGGREGATE]
├─ ./src/cook/execution/dlq.rs (11 functions, total score: 813.1)
├─ WHY: File aggregate combines complexity scores from 11 individual functions to identify files with widespread technical debt. Unlike single file-level issues (god objects, high line count), this represents accumulated complexity across multiple functions. 11 functions exceed complexity thresholds.
├─ ACTION: Focus on the top 2 high-complexity functions listed below (complexity > 10 or coverage < 60%)
│  ├─ 1. Start with these 2 functions (listed in DEPENDENCIES below)
│  ├─ 2. For each function: If coverage < 60%, add tests for uncovered lines ONLY
│  ├─ 3. For each function: If complexity > 10, apply these patterns:
│  │   • Extract guard clauses: Convert nested if-else to early returns
│  │   • Extract validation: Move input checks to separate function
│  │   • Replace conditionals with map/filter when processing collections
│  │   • Extract complex boolean expressions into named predicates
│  └─ 4. Keep refactoring focused: Extract helpers as needed, but avoid over-engineering
├─ IMPACT: Reduce overall file complexity by 100%, improve test coverage, enable safer refactoring
├─ METRICS: Functions: 11, Problematic: 11, Avg complexity: 73.9
├─ SCORING: Aggregate: CRITICAL | Avg per function: 49.0 | Max: 79.5
└─ DEPS: 11 high-complexity functions identified
   ├─ DLQStorage::update_index: 79.5
   ├─ DLQStorage::load_all: 77.5
   ├─ DeadLetterQueue::add: 77.0
   ├─ DeadLetterQueue::list_items: 76.0
   └─ DeadLetterQueue::analyze_patterns: 75.6

#6 SCORE: 446 [CRITICAL - FILE AGGREGATE]
├─ ./src/worktree/manager.rs (10 functions, total score: 704.7)
├─ WHY: File aggregate combines complexity scores from 10 individual functions to identify files with widespread technical debt. Unlike single file-level issues (god objects, high line count), this represents accumulated complexity across multiple functions. 10 functions exceed complexity thresholds.
├─ ACTION: Focus on the top 2 high-complexity functions listed below (complexity > 10 or coverage < 60%)
│  ├─ 1. Start with these 2 functions (listed in DEPENDENCIES below)
│  ├─ 2. For each function: If coverage < 60%, add tests for uncovered lines ONLY
│  ├─ 3. For each function: If complexity > 10, apply these patterns:
│  │   • Extract guard clauses: Convert nested if-else to early returns
│  │   • Extract validation: Move input checks to separate function
│  │   • Replace conditionals with map/filter when processing collections
│  │   • Extract complex boolean expressions into named predicates
│  └─ 4. Keep refactoring focused: Extract helpers as needed, but avoid over-engineering
├─ IMPACT: Reduce overall file complexity by 100%, improve test coverage, enable safer refactoring
├─ METRICS: Functions: 10, Problematic: 10, Avg complexity: 70.5
├─ SCORING: Aggregate: CRITICAL | Avg per function: 44.6 | Max: 91.0
└─ DEPS: 10 high-complexity functions identified
   ├─ WorktreeManager::cleanup_session: 91.0
   ├─ WorktreeManager::cleanup_session_after_merge: 82.3
   ├─ WorktreeManager::list_sessions: 80.1
   ├─ WorktreeManager::detect_mergeable_sessions: 77.2
   └─ WorktreeManager::list_metadata_sessions: 76.3

#7 SCORE: 117 [CRITICAL - FILE - GOD OBJECT]
└─ ./src/cook/orchestrator.rs (2730 lines, 61 functions)
└─ WHY: This class violates single responsibility principle with 49 methods, 8 fields, and 6 distinct responsibilities. High coupling and low cohesion make it difficult to maintain and test.
└─ ACTION: URGENT: 2730 lines, 61 functions! Split by data flow: 1) Input/parsing functions 2) Core logic/transformation 3) Output/formatting. Create 3 focused modules with <30 functions each.
  - 1. Identify distinct responsibilities in the class
  - 2. Group methods and fields by responsibility
  - 3. Extract each group into a separate focused class
  - 4. Use composition or dependency injection to connect the new classes
  - 3. Create new files: `orchestrator_core.rs`, `orchestrator_io.rs`, `orchestrator_utils.rs` (adjust names to match groups)
  - 4. Move functions in groups of 10-20, test after each move
  - 5. DO NOT: Try to fix everything at once. Move incrementally, test frequently
└─ IMPACT: Reduce complexity by 80%, improve testability, enable parallel development
└─ METRICS: Methods: 49, Fields: 8, Responsibilities: 6
└─ SCORING: File size: CRITICAL | Functions: EXCESSIVE | Complexity: HIGH
└─ DEPENDENCIES: 61 functions may have complex interdependencies

#8 SCORE: 94.8 [🔴 UNTESTED] [CRITICAL]
- LOCATION: ./src/commands/handlers/shell.rs:45 ShellHandler::execute()
- WHY: Complexity 7 is manageable. Coverage at 0%. Focus on test coverage, not refactoring
- ACTION: Add 7 tests for 100% coverage gap. NO refactoring needed (complexity 7 is acceptable)
   - 1. Write 7 focused tests for uncovered branches
   - 2. Each test should be <15 lines and test ONE path
   - 3. Focus on testing each decision branch independently
   - 4. Nesting depth of 3 can be reduced with guard clauses
   - 5. Move validation checks to the beginning with early returns
- IMPACT: -3 complexity, -33.2 risk
- COMPLEXITY: cyclomatic=7 (adj:4), branches=7, cognitive=41, nesting=3, entropy=0.39
- DEPENDENCIES: 18 upstream, 11 downstream
   - CALLERS: tests::test_cargo_test_with_features, CargoHandler::execute, tests::test_cargo_build, ... (15 more)
   - CALLS: AttributeSchema::apply_defaults, ShellHandler::execute, ExecutionContext::full_env, ... (8 more)

#9 SCORE: 92.9 [🔴 UNTESTED] [CRITICAL]
- LOCATION: ./src/cook/session/adapter.rs:110 SessionManagerAdapter::update_session()
- WHY: Moderate complexity (27), needs functional decomposition
- ACTION: Apply functional patterns: 6 pure functions with Iterator chains
   - 1. Extract pure functions for each logical operation:
   - 2.   • Predicates: is_valid(), should_process()
   - 3.   • Transformations: map_to_domain(), normalize()
   - 4.   • Aggregations: fold(), collect_results()
   - 5. Use Iterator methods instead of loops:
   - 6.   • filter() instead of if statements in loops
   - 7.   • map() for transformations
   - 8.   • fold() or reduce() for aggregations
   - 9.   • partition() for splitting collections
   - 10. Use property-based testing to verify function invariants
- IMPACT: -13 complexity, -32.5 risk
- COMPLEXITY: cyclomatic=27 (adj:13), branches=27, cognitive=82, nesting=2, entropy=0.36
- DEPENDENCIES: 13 upstream, 4 downstream
   - CALLERS: test_session_persistence_across_interruption, DefaultCookOrchestrator::process_workflow_input, DefaultCookOrchestrator::resume_workflow_execution, ... (10 more)
   - CALLS: ProgressDisplayImpl::progress, ProgressDisplayImpl::status, SessionState::duration, ... (1 more)

#10 SCORE: 86.1 [🔴 UNTESTED] [CRITICAL]
- LOCATION: ./src/cook/execution/state.rs:306 CheckpointManager::save_checkpoint()
- WHY: Complexity 11 is manageable. Coverage at 0%. Focus on test coverage, not refactoring
- ACTION: Add 11 tests for 100% coverage gap. NO refactoring needed (complexity 11 is acceptable)
   - 1. Write 11 focused tests for uncovered branches
   - 2. Each test should be <15 lines and test ONE path
   - 3. Extract helper functions for complex boolean expressions
   - 4. Consider using match expressions instead of if-else chains
- IMPACT: -5 complexity, -30.1 risk
- COMPLEXITY: cyclomatic=11 (adj:5), branches=11, cognitive=30, nesting=1, entropy=0.33
- DEPENDENCIES: 10 upstream, 7 downstream
   - CALLERS: tests::test_checkpoint_save_and_load, DefaultJobStateManager::mark_job_complete, DefaultJobStateManager::update_agent_result, ... (7 more)
   - CALLS: JsonlEventWriter::clone, CheckpointManager::job_dir, CheckpointManager::metadata_path, ... (4 more)

[STATS] TOTAL DEBT SCORE: 19585
