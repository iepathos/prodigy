============================================
    Debtmap v0.2.3
============================================

[TARGET] TOP 10 RECOMMENDATIONS

#1 SCORE: 1739 [CRITICAL - FILE AGGREGATE]
├─ ./src/cook/execution/mapreduce.rs (25 functions, total score: 1739.1)
├─ WHY: File aggregate combines complexity scores from 25 individual functions to identify files with widespread technical debt. Unlike single file-level issues (god objects, high line count), this represents accumulated complexity across multiple functions. 25 functions exceed complexity thresholds.
├─ ACTION: Focus on the top 2 high-complexity functions listed below (complexity > 10 or coverage < 60%)
│  ├─ 1. Start with these 2 functions (listed in DEPENDENCIES below)
│  ├─ 2. For each function: If coverage < 60%, add tests for uncovered lines ONLY
│  ├─ 3. For each function: If complexity > 10, apply these patterns:
│  │   • Extract guard clauses: Convert nested if-else to early returns
│  │   • Extract validation: Move input checks to separate function
│  │   • Replace conditionals with map/filter when processing collections
│  │   • Extract complex boolean expressions into named predicates
│  └─ 4. Keep refactoring focused: Extract helpers as needed, but avoid over-engineering
├─ IMPACT: Reduce overall file complexity by 100%, improve test coverage, enable safer refactoring
├─ METRICS: Functions: 25, Problematic: 25, Avg complexity: 69.6
├─ SCORING: Aggregate: CRITICAL | Avg per function: 69.6 | Max: 81.3
└─ DEPS: 25 high-complexity functions identified
   ├─ MapReduceExecutor::execute_reduce_phase: 81.3
   ├─ MapReduceExecutor::execute_with_context: 81.1
   ├─ MapReduceExecutor::resume_job_with_options: 79.3
   ├─ MapReduceExecutor::find_missing_variables: 79.1
   └─ MapReduceExecutor::execute_agent_commands_with_progress: 78.4

#2 SCORE: 1686 [CRITICAL - FILE AGGREGATE]
├─ ./src/cook/workflow/executor.rs (24 functions, total score: 1721.2)
├─ WHY: File aggregate combines complexity scores from 24 individual functions to identify files with widespread technical debt. Unlike single file-level issues (god objects, high line count), this represents accumulated complexity across multiple functions. 24 functions exceed complexity thresholds.
├─ ACTION: Focus on the top 2 high-complexity functions listed below (complexity > 10 or coverage < 60%)
│  ├─ 1. Start with these 2 functions (listed in DEPENDENCIES below)
│  ├─ 2. For each function: If coverage < 60%, add tests for uncovered lines ONLY
│  ├─ 3. For each function: If complexity > 10, apply these patterns:
│  │   • Extract guard clauses: Convert nested if-else to early returns
│  │   • Extract validation: Move input checks to separate function
│  │   • Replace conditionals with map/filter when processing collections
│  │   • Extract complex boolean expressions into named predicates
│  └─ 4. Keep refactoring focused: Extract helpers as needed, but avoid over-engineering
├─ IMPACT: Reduce overall file complexity by 100%, improve test coverage, enable safer refactoring
├─ METRICS: Functions: 24, Problematic: 24, Avg complexity: 71.7
├─ SCORING: Aggregate: CRITICAL | Avg per function: 70.3 | Max: 81.3
└─ DEPS: 24 high-complexity functions identified
   ├─ WorkflowExecutor::execute: 81.3
   ├─ WorkflowExecutor::execute_shell_with_retry: 81.3
   ├─ WorkflowExecutor::execute_test_command: 81.3
   ├─ WorkflowExecutor::execute_step: 81.2
   └─ WorkflowExecutor::handle_on_failure: 81.2

#3 SCORE: 1090 [CRITICAL - FILE AGGREGATE]
├─ ./src/cook/orchestrator.rs (18 functions, total score: 1285.0)
├─ WHY: File aggregate combines complexity scores from 18 individual functions to identify files with widespread technical debt. Unlike single file-level issues (god objects, high line count), this represents accumulated complexity across multiple functions. 18 functions exceed complexity thresholds.
├─ ACTION: Focus on the top 2 high-complexity functions listed below (complexity > 10 or coverage < 60%)
│  ├─ 1. Start with these 2 functions (listed in DEPENDENCIES below)
│  ├─ 2. For each function: If coverage < 60%, add tests for uncovered lines ONLY
│  ├─ 3. For each function: If complexity > 10, apply these patterns:
│  │   • Extract guard clauses: Convert nested if-else to early returns
│  │   • Extract validation: Move input checks to separate function
│  │   • Replace conditionals with map/filter when processing collections
│  │   • Extract complex boolean expressions into named predicates
│  └─ 4. Keep refactoring focused: Extract helpers as needed, but avoid over-engineering
├─ IMPACT: Reduce overall file complexity by 100%, improve test coverage, enable safer refactoring
├─ METRICS: Functions: 18, Problematic: 18, Avg complexity: 71.4
├─ SCORING: Aggregate: CRITICAL | Avg per function: 60.6 | Max: 81.2
└─ DEPS: 18 high-complexity functions identified
   ├─ DefaultCookOrchestrator::run: 81.2
   ├─ DefaultCookOrchestrator::execute_structured_workflow: 81.1
   ├─ DefaultCookOrchestrator::resume_workflow: 81.1
   ├─ DefaultCookOrchestrator::execute_and_validate_command: 81.1
   └─ DefaultCookOrchestrator::restore_environment: 76.4

#4 SCORE: 860 [CRITICAL - FILE AGGREGATE]
├─ ./src/cli/events.rs (16 functions, total score: 1074.6)
├─ WHY: File aggregate combines complexity scores from 16 individual functions to identify files with widespread technical debt. Unlike single file-level issues (god objects, high line count), this represents accumulated complexity across multiple functions. 16 functions exceed complexity thresholds.
├─ ACTION: Focus on the top 2 high-complexity functions listed below (complexity > 10 or coverage < 60%)
│  ├─ 1. Start with these 2 functions (listed in DEPENDENCIES below)
│  ├─ 2. For each function: If coverage < 60%, add tests for uncovered lines ONLY
│  ├─ 3. For each function: If complexity > 10, apply these patterns:
│  │   • Extract guard clauses: Convert nested if-else to early returns
│  │   • Extract validation: Move input checks to separate function
│  │   • Replace conditionals with map/filter when processing collections
│  │   • Extract complex boolean expressions into named predicates
│  └─ 4. Keep refactoring focused: Extract helpers as needed, but avoid over-engineering
├─ IMPACT: Reduce overall file complexity by 100%, improve test coverage, enable safer refactoring
├─ METRICS: Functions: 16, Problematic: 16, Avg complexity: 67.2
├─ SCORING: Aggregate: CRITICAL | Avg per function: 53.7 | Max: 81.4
└─ DEPS: 16 high-complexity functions identified
   ├─ get_event_type: 81.4
   ├─ follow_events: 81.2
   ├─ list_events: 78.7
   ├─ search_aggregated_events: 78.3
   └─ process_event_for_status: 76.8

#5 SCORE: 703 [CRITICAL - FILE AGGREGATE]
├─ ./src/worktree/manager.rs (14 functions, total score: 939.3)
├─ WHY: File aggregate combines complexity scores from 14 individual functions to identify files with widespread technical debt. Unlike single file-level issues (god objects, high line count), this represents accumulated complexity across multiple functions. 14 functions exceed complexity thresholds.
├─ ACTION: Focus on the top 2 high-complexity functions listed below (complexity > 10 or coverage < 60%)
│  ├─ 1. Start with these 2 functions (listed in DEPENDENCIES below)
│  ├─ 2. For each function: If coverage < 60%, add tests for uncovered lines ONLY
│  ├─ 3. For each function: If complexity > 10, apply these patterns:
│  │   • Extract guard clauses: Convert nested if-else to early returns
│  │   • Extract validation: Move input checks to separate function
│  │   • Replace conditionals with map/filter when processing collections
│  │   • Extract complex boolean expressions into named predicates
│  └─ 4. Keep refactoring focused: Extract helpers as needed, but avoid over-engineering
├─ IMPACT: Reduce overall file complexity by 100%, improve test coverage, enable safer refactoring
├─ METRICS: Functions: 14, Problematic: 14, Avg complexity: 67.1
├─ SCORING: Aggregate: CRITICAL | Avg per function: 50.2 | Max: 81.1
└─ DEPS: 14 high-complexity functions identified
   ├─ WorktreeManager::merge_session: 81.1
   ├─ WorktreeManager::cleanup_session_after_merge: 79.6
   ├─ WorktreeManager::detect_mergeable_sessions: 75.4
   ├─ WorktreeManager::list_metadata_sessions: 75.4
   └─ WorktreeManager::cleanup_session: 74.8

#6 SCORE: 593 [CRITICAL - FILE AGGREGATE]
├─ ./src/main.rs (12 functions, total score: 855.8)
├─ WHY: File aggregate combines complexity scores from 12 individual functions to identify files with widespread technical debt. Unlike single file-level issues (god objects, high line count), this represents accumulated complexity across multiple functions. 12 functions exceed complexity thresholds.
├─ ACTION: Focus on the top 2 high-complexity functions listed below (complexity > 10 or coverage < 60%)
│  ├─ 1. Start with these 2 functions (listed in DEPENDENCIES below)
│  ├─ 2. For each function: If coverage < 60%, add tests for uncovered lines ONLY
│  ├─ 3. For each function: If complexity > 10, apply these patterns:
│  │   • Extract guard clauses: Convert nested if-else to early returns
│  │   • Extract validation: Move input checks to separate function
│  │   • Replace conditionals with map/filter when processing collections
│  │   • Extract complex boolean expressions into named predicates
│  └─ 4. Keep refactoring focused: Extract helpers as needed, but avoid over-engineering
├─ IMPACT: Reduce overall file complexity by 100%, improve test coverage, enable safer refactoring
├─ METRICS: Functions: 12, Problematic: 12, Avg complexity: 71.3
├─ SCORING: Aggregate: CRITICAL | Avg per function: 49.4 | Max: 81.2
└─ DEPS: 12 high-complexity functions identified
   ├─ run_resume_workflow: 81.2
   ├─ run_sessions_command: 81.1
   ├─ handle_single_cleanup: 74.3
   ├─ resolve_job_id: 73.3
   └─ merge_single_session: 71.3

#7 SCORE: 532 [CRITICAL - FILE AGGREGATE]
├─ ./src/cook/execution/dlq.rs (11 functions, total score: 802.4)
├─ WHY: File aggregate combines complexity scores from 11 individual functions to identify files with widespread technical debt. Unlike single file-level issues (god objects, high line count), this represents accumulated complexity across multiple functions. 11 functions exceed complexity thresholds.
├─ ACTION: Focus on the top 2 high-complexity functions listed below (complexity > 10 or coverage < 60%)
│  ├─ 1. Start with these 2 functions (listed in DEPENDENCIES below)
│  ├─ 2. For each function: If coverage < 60%, add tests for uncovered lines ONLY
│  ├─ 3. For each function: If complexity > 10, apply these patterns:
│  │   • Extract guard clauses: Convert nested if-else to early returns
│  │   • Extract validation: Move input checks to separate function
│  │   • Replace conditionals with map/filter when processing collections
│  │   • Extract complex boolean expressions into named predicates
│  └─ 4. Keep refactoring focused: Extract helpers as needed, but avoid over-engineering
├─ IMPACT: Reduce overall file complexity by 100%, improve test coverage, enable safer refactoring
├─ METRICS: Functions: 11, Problematic: 11, Avg complexity: 72.9
├─ SCORING: Aggregate: CRITICAL | Avg per function: 48.4 | Max: 77.7
└─ DEPS: 11 high-complexity functions identified
   ├─ DLQStorage::update_index: 77.7
   ├─ DLQStorage::load_all: 76.6
   ├─ DeadLetterQueue::list_items: 76.0
   ├─ DeadLetterQueue::analyze_patterns: 75.6
   └─ DeadLetterQueue::reprocess: 74.5

#8 SCORE: 523 [CRITICAL - FILE AGGREGATE]
├─ ./src/cook/execution/data_pipeline.rs (11 functions, total score: 789.2)
├─ WHY: File aggregate combines complexity scores from 11 individual functions to identify files with widespread technical debt. Unlike single file-level issues (god objects, high line count), this represents accumulated complexity across multiple functions. 11 functions exceed complexity thresholds.
├─ ACTION: Focus on the top 2 high-complexity functions listed below (complexity > 10 or coverage < 60%)
│  ├─ 1. Start with these 2 functions (listed in DEPENDENCIES below)
│  ├─ 2. For each function: If coverage < 60%, add tests for uncovered lines ONLY
│  ├─ 3. For each function: If complexity > 10, apply these patterns:
│  │   • Extract guard clauses: Convert nested if-else to early returns
│  │   • Extract validation: Move input checks to separate function
│  │   • Replace conditionals with map/filter when processing collections
│  │   • Extract complex boolean expressions into named predicates
│  └─ 4. Keep refactoring focused: Extract helpers as needed, but avoid over-engineering
├─ IMPACT: Reduce overall file complexity by 100%, improve test coverage, enable safer refactoring
├─ METRICS: Functions: 11, Problematic: 11, Avg complexity: 71.7
├─ SCORING: Aggregate: CRITICAL | Avg per function: 47.6 | Max: 81.2
└─ DEPS: 11 high-complexity functions identified
   ├─ JsonPath::compile: 81.2
   ├─ FilterExpression::compare: 81.0
   ├─ DataPipeline::process: 76.4
   ├─ Sorter::parse: 76.1
   └─ Sorter::compare_json_values: 73.3

#9 SCORE: 433 [CRITICAL - FILE AGGREGATE]
├─ ./src/cook/execution/progress.rs (10 functions, total score: 685.3)
├─ WHY: File aggregate combines complexity scores from 10 individual functions to identify files with widespread technical debt. Unlike single file-level issues (god objects, high line count), this represents accumulated complexity across multiple functions. 10 functions exceed complexity thresholds.
├─ ACTION: Focus on the top 2 high-complexity functions listed below (complexity > 10 or coverage < 60%)
│  ├─ 1. Start with these 2 functions (listed in DEPENDENCIES below)
│  ├─ 2. For each function: If coverage < 60%, add tests for uncovered lines ONLY
│  ├─ 3. For each function: If complexity > 10, apply these patterns:
│  │   • Extract guard clauses: Convert nested if-else to early returns
│  │   • Extract validation: Move input checks to separate function
│  │   • Replace conditionals with map/filter when processing collections
│  │   • Extract complex boolean expressions into named predicates
│  └─ 4. Keep refactoring focused: Extract helpers as needed, but avoid over-engineering
├─ IMPACT: Reduce overall file complexity by 100%, improve test coverage, enable safer refactoring
├─ METRICS: Functions: 10, Problematic: 10, Avg complexity: 68.5
├─ SCORING: Aggregate: CRITICAL | Avg per function: 43.3 | Max: 81.1
└─ DEPS: 10 high-complexity functions identified
   ├─ CLIProgressViewer::display: 81.1
   ├─ ProgressPersistence::append_to_history: 73.9
   ├─ ProgressWebServer::handle_socket: 73.3
   ├─ EnhancedProgressTracker::start_persistence: 72.8
   └─ EnhancedProgressTracker::restore_from_disk: 72.0

#10 SCORE: 410 [CRITICAL - FILE AGGREGATE]
├─ ./src/worktree/pool.rs (10 functions, total score: 648.2)
├─ WHY: File aggregate combines complexity scores from 10 individual functions to identify files with widespread technical debt. Unlike single file-level issues (god objects, high line count), this represents accumulated complexity across multiple functions. 10 functions exceed complexity thresholds.
├─ ACTION: Focus on the top 2 high-complexity functions listed below (complexity > 10 or coverage < 60%)
│  ├─ 1. Start with these 2 functions (listed in DEPENDENCIES below)
│  ├─ 2. For each function: If coverage < 60%, add tests for uncovered lines ONLY
│  ├─ 3. For each function: If complexity > 10, apply these patterns:
│  │   • Extract guard clauses: Convert nested if-else to early returns
│  │   • Extract validation: Move input checks to separate function
│  │   • Replace conditionals with map/filter when processing collections
│  │   • Extract complex boolean expressions into named predicates
│  └─ 4. Keep refactoring focused: Extract helpers as needed, but avoid over-engineering
├─ IMPACT: Reduce overall file complexity by 100%, improve test coverage, enable safer refactoring
├─ METRICS: Functions: 10, Problematic: 10, Avg complexity: 64.8
├─ SCORING: Aggregate: CRITICAL | Avg per function: 41.0 | Max: 73.8
└─ DEPS: 10 high-complexity functions identified
   ├─ WorktreePool::acquire_reusable_worktree: 73.8
   ├─ WorktreePool::cleanup_all: 73.6
   ├─ WorktreePool::acquire_anonymous_worktree: 73.1
   ├─ WorktreePool::release_worktree: 73.0
   └─ WorktreePool::create_new_worktree: 72.9

[STATS] TOTAL DEBT SCORE: 25709
